#+title: Externally-dynamic dynamic semantics
#+author: Patrick D. Elliott 
#+bibliography: ../../bibliography/master.bib
#+setupfile: handout-template.org
#+OPTIONS: ':t
#+cite_export: biblatex

* Externally-dynamic dynamic semantics

In the first generation dynamic systems we've considered, culminating in pointwise FCS, dynamics are a sentential phenomenon.

Charlow teaches us how to factor out dynamics into our compositional regime. We'll make use of this in EDS [cite:@Charlow2014;@Charlow2020].

First, we adopt Charlow's general recipe for a dynamic type.[fn:1][fn:2]

#+name: def:type
#+begin_exe
\ex \(D\ a := g \to \set{(a \times g)}\)
#+end_exe

For example, sentences in EDS will be type \(D\ t\); VPs in EDS will be type \(D\ (e \to t)\).

** Pronouns and partiality

In EDS, much like in Charlow's monadic grammar, pronouns are expressions of type \(D\ e\), i.e., /dynamic individuals/.

In EDS, assignments are assumed to be /partial/, i.e., undefined for certain variables.

We'll model this by treating the domain of assignments (\(D_g\)) as a set of /total/ functions \(f: V \to D_e\), where \(D_e\) contains a privileged value \(\#_e\) - the impossible individual.[fn:3]

For example, given a stock of variables \(\set{x,y,z}\), the following is a partial assignment:

#+name: ex:part
#+begin_exe
\ex \(\left[\begin{aligned}[c]
&x &\to &\mathbf{josie}\\
&y &\to &\mathbf{sarah}\\
&z &\to &\#_e
\end{aligned}\right]\)
#+end_exe

The unique initial assignment, \(g_\top\), maps every \(v \in V\) to the impossible individual.

Pronouns have the following semantics in EDS:

#+name: def:eds-pron
#+begin_exe
\ex \(\mathbf{she}_v := \lambda g\,.\,\set{(g_v,g)}\)\hfill\(D\ e\)
#+end_exe

Since EDS builds on a Strong Kleene logical foundation, we'll make use of three distinct truth values:

#+name: def:tri
#+begin_exe
\ex \(D_t = \set{\mathbf{yes},\mathbf{no},\mathbf{maybe}}\)
#+end_exe

We'll make use of an operator \(\delta : t \to t \) to model presuppositions, with the following semantics.

#+name: def:delta
#+begin_exe
\ex \(\delta(t) = \begin{cases}
\mathbf{yes}&t = \mathbf{yes}\\
\mathbf{maybe}&\text{otherwise} 
\end{cases}\)
#+end_exe

Sentences with a pronoun indexed \(v\) presuppose that \(v\) is defined at the input assignment. Formally:

#+name: ex:sentence1
#+begin_exe
\ex \(\mathbf{she}_v\ \mathbf{satDown} := \lambda g\,.\,\set{(\delta(g_v \neq \#_e) \mathbin{\&} \mathbf{satDown}(g_v),g)}\)
#+end_exe

An alternative rendering:

#+name: ex:sentence2
#+begin_exe
\ex \(\lambda g\,.\,\begin{aligned}[t]
&\set{(\mathbf{yes},g)|\mathbf{satDown}(g_v) \wedge g_v \neq \#_e}\\
&\cup \set{(\mathbf{no},g)|\neg\mathbf{satDown}(g_v) \wedge g_v \neq \#_e}\\
&\cup \set{(\mathbf{maybe},g)|g_v = \#_e}
\end{aligned}\)
#+end_exe

** Indefinites

*** Random assignment in EDS

It will be helpful to first define the correlate of DPL /random assignment/ in EDS (relative to a restrictor \(r\)).

#+name: def:random
#+begin_exe
\ex \(\varepsilon^{v} = \lambda r\,.\,\lambda k\,.\,\lambda g\,.\,\bigcup\limits_{r(x)}k(x)(g^{[v \to x]})\)\hfill\((e \to D\ t) \to D\ t\)
#+end_exe

Let's see this in action (importantly, this is *not* our entry for the indefinite determiner).

#+name: ex:rand
#+begin_exe
\ex \(\varepsilon^v(\mathbf{ling})(\lambda x\,.\,\lambda g\,.\,\set{(\mathbf{swims}(x),g)})\)\hfill\(D\ t\)
\ex \(\lambda g\,.\,\set{(\mathbf{swim}(x),g^{[v \to x]})|\mathbf{ling}(x)}\)
#+end_exe

An equivalent, illuminating rendering:

#+name: ex:rand2
#+begin_exe
\ex \(\lambda g\,.\,\set{(\mathbf{yes},g^{[v \to x]})|\mathbf{ling}(x) \wedge \mathbf{swim}(x)} \cup \set{(\mathbf{no},g^{[v \to x]})|\mathbf{ling}(x) \wedge  \mathbf{swim}(x)}\)
#+end_exe

We take an input assingment \(g\), and extend \(g\) indeterministically at \(v\) (DPL style) to linguists, and:

- Tag those assignments extended to a linguist who swims with \(\mathbf{yes}\).
- Tag those assignments extended to a linguist who doesn't swim with \(\mathbf{no}\).
  
We'll define an auxiliary notion now which will come in handy in a few different places: the /polarized anaphoric information/ of a sentence relative to an assignment, which we'll write as \(\mathbf{A}^+_g/\mathbf{A}^-_g\).

#+name: def:polar
#+begin_exe
\ex \(\mathbf{A}^+_g(p) := \set{h | (\mathbf{yes},h) \in p(g)}\)
\ex \(\mathbf{A}^-_g(p) := \set{h | (\mathbf{no},h) \in p(g)}\)
#+end_exe

We can use this notion to provide an intuitive definition of truth at a point: a sentence is /true/ wrt an assignment \(g\) if there is some way of verifying \(p\) at \(g\), /false/ if there is no way of verifying \(p\) at \(g\), but some way of falsifying \(p\) at \(g\), and neither true nor false otherwise.

#+name: def:truth
#+begin_exe
\ex \(\mathbf{true}_g(p) := \mathbf{A}^+_g(p) \neq \emptyset\)
\ex \(\mathbf{false}_g(p) := \mathbf{A}^+_g(p) = \emptyset \wedge \mathbf{A}^-_g(p) \neq \emptyset\)
\ex \(\mathbf{neither}_g(p) := \mathbf{A}^+_g(p) = \emptyset \wedge \mathbf{A}^-_g(p) = \emptyset \)
#+end_exe

Finally, we state our /positive closure operator/ \(\dag_g\), which will be crucially implicated in our semantics for the indefinite article.

The positive closure operator only allows anaphoric information to pass through if its argument is classically true.

#+name: def:dag
#+begin_exe
\ex \(\dag(p)(g) := \set{(\mathbf{yes},h) \in p(g)} \cup \set{(\mathbf{no},g)|\mathbf{false}_g(p)} \cup \set{(\mathbf{maybe},g)|\mathbf{neither}_g(p)}\)
#+end_exe

The following is a logical truth in EDS (dagger elimination):

#+name: fact:clo
#+begin_exe
\ex \(\mathbf{A}^+_g(\dag(p)) = \mathbf{A}^+_g(p)\)
#+end_exe

Now we can state our final proposal for the semantics of indefinites as the composition of random assignment and positive closure.

#+name: def:indef-final
#+begin_exe
\ex \(\mathbf{a.ling}^v := \lambda k\,.\,\dag(\varepsilon^v(\mathbf{ling})(k))\)\hfill\((e \to D\ t) \to D\ t\)
#+end_exe 

#+name: ex:indef-final
#+begin_exe
\ex \(\mathbf{a.ling}^v\ (\lambda x\,.\,\lambda g\,.\,\set{(\mathbf{swim}(x),g)})\)
\ex \(= \dag(\varepsilon^v(\mathbf{ling})(\lambda x\,.\,\lambda g\,.\,\set{(\mathbf{swim}(x),g)}))\)
\ex \(= \lambda g\,.\,\set{(\mathbf{yes},g^{[v \to x]})|\mathbf{ling}(x) \wedge \mathbf{swim}(x)} \cup \set{(\mathbf{no},g)|\neg\exists x[\mathbf{ling}(x) \wedge \mathbf{swim}(x)]}\)
#+end_exe

The input assignment is indeterministically extended at \(v\) to linguists who swim, and paired with \(\mathbf{yes}\); if there aren't any linguists who swim, the input assignment is paired with \(\mathbf{no}\).

** Compositionality

As a methodological principle, we'll insist that proper names, predicates, logical expressions etc. don't have any inherent dynamics.

#+name: ex:classic
#+begin_exe
\ex \(\mathbf{John} : t\)
\ex \(\mathbf{swim} : e \to  t\)
\ex \(\mathbf{not} : t \to t\)
#+end_exe

Only a sub-part of the grammar wears its dynamic capabilities on its sleeve.

In order to lift expressions without inherent dynamics into EDS, we need just three combinators, which constitute an /applicative functor/.

/Pure/ (\(\eta\)) lifts any expression \(a\) into a trivially dynamic \(a\). 

#+name: def:pure
#+begin_exe
\ex \(\eta(a) := \lambda g\,.\,\set{(a,g)}\)\hfill\(\eta : a \to D\ a\)
#+end_exe

/Dynamic FA/ (\(\fap\)) does function application and threads anaphoric information from left-to-right.

#+name: def:fap
#+begin_exe
\ex \(m \fap n := \lambda g\,.\,\bigcup\limits_{(f,g') \in m(g)}\set{(f(x),g'')|(x,g'') \in n(g')}\)\hfill\((\fap) : D\ (a \to b) \to D\ a \to D\ b\)
#+end_exe

/Dynamic backwards FA/ (\(\bap\)) does backwards function application and threads anaphoric information from left-to-right.

#+name: def:bap
#+begin_exe
\ex \(m \bap n := \lambda g\,.\,\bigcup\limits_{(x,g') \in m(g)}\set{(f(x),g'')|(f,g'') \in n(g')}\)\hfill\((\bap): D\ a \to D\ (a \to b) \to D\ b\)
#+end_exe

Composition:

#+begin_export latex
\begin{exe}
\ex
\(\eval*{\begin{array}{c}
\begin{forest}
[{\(\gamma\)}
  [{\(\alpha_{D\ (a \to b)}\)}]
  [{\(\beta_{D\ a}\)}]
]
\end{forest}
\end{array}} = \eval*{\alpha } \fap \eval*{\beta }\)
\ex
\(\eval*{\begin{array}{c}
\begin{forest}
[{\(\gamma\)}
  [{\(\alpha_{D\ a}\)}]
  [{\(\beta_{D\ (a \to b)}\)}]
]
\end{forest}
\end{array}} = \eval*{\alpha } \bap \eval*{\beta }\)
\end{exe}
#+end_export

Note that i'm assuming that the flow of anaphoric information is conditioned by linear order, but a different assumption is just a matter of adjusting the rules stated above (cf. [cite:@Privoznov2021]).

Some exercises - note that in-scope dynamic binding follows immediately from the composition principles and our semantics for indefinites (which extends DPL-style random assignment).

#+name: pro-comp
#+begin_exe
\ex \(\mathbf{she}_v \bap \eta(\mathbf{sat.down}) = \lambda g\,.\,\set{(\mathbf{satDown}(g_v),g)}\)
\ex \(\mathbf{a.ling}^v\ (\lambda x\,.\,\eta(\mathbf{walked.in}(x))) = \dag(\varepsilon^v(\mathbf{ling})(\lambda x\,.\,\lambda g\,.\,\set{(\mathbf{walked.in}(x),g)}))\)
\ex \(\mathbf{a.ling}^v\ (\lambda x\,.\,\eta(\mathbf{introduced}(\mathbf{j})) \fap (\mathbf{her_v\,.\,\mathbf{mother}})) = \dag(\varepsilon^v(\mathbf{ling})(\lambda x\,.\,\lambda g\,.\,\set{(\mathbf{introduce}(j)(\mathbf{mother.of}\ g_v)(x),g)}))\)
#+end_exe


** Lifting logical operators

*** Strong Kleene

Strong Kleene semantics is a logical encoding of how we reason about uncertainty/indeterminate truth.

#+begin_export latex
\begin{figure}[H]
    \centering
  \begin{tabular}{l|r}
      $\mathbf{not}$  &  \\
      \toprule
      $\mathbf{yes}$  & $\mathbf{no}$   \\
      $\mathbf{no}$  & $\mathbf{yes}$   \\
      $\mathbf{maybe}$ & $\mathbf{maybe}$
  \end{tabular}
  \quad
  \begin{tabular}{l|ccc}
      $\wedge _{s}$  & $\mathbf{yes}$ & $\mathbf{no}$ & $\mathbf{maybe}$ \\
      \toprule
      $\mathbf{yes}$  & $\mathbf{yes}$  & $\mathbf{no}$ & $\mathbf{maybe}$\\
      $\mathbf{no}$  & $\mathbf{no}$  & $\mathbf{no}$ & $\mathbf{no}$\\
      $\mathbf{maybe}$ & $\mathbf{maybe}$ & $\mathbf{no}$ & $\mathbf{maybe}$\\
  \end{tabular}
\quad
  \begin{tabular}{l|ccc}
      $\vee_{s}$  & $\mathbf{yes}$ & $\mathbf{no}$ & $\mathbf{maybe}$ \\
      \toprule
      $\mathbf{yes}$  & $\mathbf{yes}$  & $\mathbf{yes}$ & $\mathbf{yes}$\\
      $\mathbf{no}$  & $\mathbf{yes}$  & $\mathbf{no}$ & $\mathbf{maybe}$\\
      $\mathbf{maybe}$ & $\mathbf{yes}$ & $\mathbf{maybe}$ & $\mathbf{maybe}$\\
  \end{tabular}
  \quad
  \begin{tabular}{l|ccc}
      $\rightarrow_{s}$  & $\mathbf{yes}$ & $\mathbf{no}$ & $\mathbf{maybe}$ \\
      \toprule
      $\mathbf{yes}$  & $\mathbf{yes}$  & $\mathbf{no}$ & $\mathbf{maybe}$\\
      $\mathbf{no}$  & $\mathbf{yes}$  & $\mathbf{yes}$ & $\mathbf{yes}$\\
      $\mathbf{maybe}$ & $\mathbf{yes}$ & $\mathbf{maybe}$ & $\mathbf{maybe}$\\
  \end{tabular}
  \caption{Strong Kleene truth tables}\label{table:neg}
\end{figure}
#+end_export

*** Negation

Our compositional regime dictates that negation, a sentential operator must be lifted via \(\eta\) and compose with its argument via \(\fap\).

#+begin_export latex
\begin{forest}
[{\(D\ t\)\\\(\fap\)}
  [{\(D\ (t \to t)\)\\\(\eta(\mathbf{not})\)}]
  [{\(D\ t\)\\\(p\)}]
]
\end{forest}
#+end_export

This predicts the following semantics for negated sentences:

#+name: ex:neg
#+begin_exe
\ex \(\eta(\mathbf{not}) \fap p\)
\ex \(= \lambda g\,.\,\set{(\neg_s(t),h)|(t,h) \in p(g)}\)
#+end_exe

In other words, negation simply flips the polarity of the output assignments.

When we apply negation to a sentence with an indefinite, truth-values in the output set are flipped.

#+name: no-ling
#+begin_exe
\ex \(\eta(\mathbf{not}) \fap (\mathbf{a.ling}^v (\lambda x\,.\,\eta(\mathbf{swims}(x))))\)
\ex \(= \lambda g\,.\,\set{(\neg_s(\mathbf{yes}),g^{[v \to x]})|\mathbf{ling}(x) \wedge \mathbf{swims}(x)} \cup \set{(\neg_s(\mathbf{no}),g)|\neg\exists x[\mathbf{ling}(x) \wedge \mathbf{swims}(x)]}\)
\ex \(= \lambda g\,.\,\set{\mathbf{no},g^{[v \to x]})|\mathbf{ling}(x) \wedge \mathbf{swims}(x)} \cup \set{(\mathbf{yes},g)|\neg\exists x[\mathbf{ling}(x) \wedge \mathbf{swims}(x)]}\)
#+end_exe

Consequence: if the negated sentence is classically true, no anaphoric information is introduced. 

One of the core insights of DPL is that this seems desirable, but in DPL this is essentially precompiled into the meaning of logical negation.

#+name: no
#+begin_exe
\ex John doesn't have a\(^v\) shirt. ??It\(_v\)'s in the closet.
#+end_exe

In EDS, by way of contrast, we don't precompile anything to do with dynamics into the meaning of negation.

Moreover, this example teaches us why random assignment (\(\varepsilon^v\)) isn't fit for purpose as a semantics for the indefinite article in EDS.

* References

#+print_bibliography:

* Footnotes
[fn:3] See [cite:@Mandelkern2022] for a similar set up. 

[fn:2] Initially, we'll present EDS as an extensional system; ultimately, everything will need to be intensionalized. 
 
[fn:1] \(a\) is an implicitly universally-quantified variable over types.

* File local variables                                             :noexport:

# Local Variables:
# mode: org
# org-latex-default-packages-alist: nil
# org-latex-with-hyperref: nil
# End:

