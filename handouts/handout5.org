#+title: Actual and hypothetical discourse referents
#+author: Patrick D. Elliott 
#+bibliography: ../../bibliography/master.bib
#+setupfile: handout-template.org
#+OPTIONS: ':t
#+cite_export: biblatex

* Some data

A generalization that emerges from EDS: an assertion of a sentence \(\phi \) containing an existential statement "a\(^v\) linguist \(P\)-ed" introduces a dref \(v\) if the assertion is accepted and contextually entails the existence of a linguist that \(P\)-ed.

Interaction with modality draws this generalization into question.

Modal subordination and anaphora [cite:@Roberts1989]:

#+name: hypothetical2
#+begin_exe
\ex Maybe there's a\(^v\) bathroom, and maybe it\(_v\)'s upstairs.
\ex There might be a\(^v\) bathroom, and it\(_v\) might be upstairs.
#+end_exe

Modal subordination with negation; data from [cite:@Hofmann2019]:

#+name: hypothetical3
#+begin_exe
\ex There is no\(^v\) bathroom in this house. It\(_v\) would be easier to find.
#+end_exe

Not possible with disjunction:

#+begin_exe
\ex ??Maybe there's a\(^v\) bathroom, or maybe it\(_v\)'s upstairs.
\ex ??There might be a\(^v\) bathroom, or it\(_v\) might be upstairs.
#+end_exe

Surprisingly, conjunctive possibility statements can pattern with disjunction: 

#+name: hypothetical1
#+begin_exe
\ex There might be no\(^v\) bathroom, and it\(_v\) might be upstairs.
\ex Maybe there's no\(^v\) bathroom, and maybe it\(_v\)'s upstairs. 
\ex Either There's no\(^v\) bathroom, or it\(_v\)'s upstairs.
#+end_exe

Note that this parallel is perhaps unsurprising, given modal theories of disjunction which validate \(\phi \vee \psi \vdash \Diamond\phi \wedge \Diamond\psi\) [cite:@Zimmermann2000;@Geurts2005;@Goldstein2019].

* Epistemic modality in dynamic semantics

** Test semantics

The /locus classicus/ is Veltman's test semantics [cite:@Veltman1996].

Veltman's idea: a sentence \(\Diamond\phi \) is an instruction to hypothetically update a context \(c\) with \(\phi \), returning \(c\) unchanged if \(c\) can be consistently updated with \(\phi\), and the absurd state otherwise. 

#+name: might1
#+begin_exe
\ex \(c[\text{it might be raining}]\)
\begin{xlist}
\ex Compute \(c[\text{it's raining}]\); store the result as \(c'\).
\ex Is \(c'\) are non-absurd information state? If so, return \(c\).
\ex Otherwise, return \(c'\).
\end{xlist}
#+end_exe

An update semantics for a simple propositional fragment [cite:@Veltman1996].

#+begin_definition
*Test semantics for /might/.*

\[c[\Diamond \phi] := \begin{cases}
c & c[\phi] \neq \emptyset\\
\phi & \text{otherwise} 
\end{cases}\]
#+end_definition

In Veltman's update semantics, \(\emptyset \) is the /absurd state/, i.e., the information state from which everything follows.

If we define update-semantic negation, we can treat /must/ as the dual of /might/.

#+name: def:neg
#+begin_exe
\ex \(c[\neg \phi] := c - c[\phi]\)
#+end_exe

#+begin_definition
*Test semantics for /must/.*

\[c[\Box \phi] := c[\neg\Diamond\neg\phi]\]

\[c[\Box \phi] := \begin{cases}
c&c[\phi] = c\\
\emptyset&\text{otherwise} 
\end{cases}\]
#+end_definition

In Veltman's terms, /must \(\phi \)/ is true in a context \(c\) if \(\phi \) is /accepted/ in \(c \).

Note that test semantics for /must/ is *strong* [cite:@vonFintelGillies2010;@FintelGillies2021].

#+begin_definition
*Entailment in update semantics.*

\(\phi\text{ entails }\psi \iff \forall c[c[\phi] = c \rightarrow c[\psi] = c]\)
#+end_definition

If \(c[\Box\phi] = c\) then \(c[\phi] = c\), simply by the update rule for \(\Box \phi \).

* Modals introduce hypothetical discourse referents

*Conjecture*: asserting "possibly \(\phi \)" is analogous to asserting "\(\phi \) or not \(\phi \)".
  
In a classical setting \(\phi \vee \neg \phi\) is of course informationally trivial, but in a dynamic setting (specifically, in the context of EDS), \(\phi \vee \neg \phi \), can introduce anaphoric information.

A consideration of the disjunctive case will help give a feel for the explanation.

#+name: triv1
#+begin_exe
\ex Either there's a\(^v\) bathroom, or there's no\(^v\) bathroom.
\ex \(\exists_v[B(v)] \vee \neg\exists_v[B(v)]\)
#+end_exe

Predicted (positive) meaning in EDS is as follows. Note:

- Since the disjuncts are mutually exclusive, we can ignore the case of both disjuncts being true.
- Since neither disjunct contains a free variable, we can ignore the case of either disjunct being undefined (ignoring the novelty condition for simplicity).
- There are therefore two ways of dynamically verifying the disjunction to consider:
  * The first disjunct is true, and the second is false (a bathroom dref).[fn:1]
  * The first disjunct is false and the second is true (no bathroom dref).
    
#+name: triv2
#+begin_exe
\ex \(\lambda (w,g)\,.\,\begin{aligned}[t]
&\set{g^{[v \to x]}|\mathbf{bathroom}_w(x)}\\
&\cup \set{g | \mathbf{bathroom}_w = \emptyset }
\end{aligned}\)
#+end_exe

An assertion of ([[triv2]]) relative to a context \(c\) will introduce a bathroom discourse referent at worlds \(\in c\) where a bathroom exists, but otherwise leave the context unchanged, e.g.:

#+name: bath-ill
#+begin_exe
\ex \(\begin{aligned}[t]
&\set{(w_\emptyset,g),(w_{1},g),(w_{2},g),(w_{12},g)}\\
&\Rightarrow \set{(w_\emptyset,g),(w_{b_1},g^{[v \to b_1]}),(w_{b_2},g^{[v \to b_2]}),(w_{b_1,b_2},g^{[v \to b_1]}),(w_{b_1,b_2},g^{[v \to b_2]})}
\end{aligned}\)
#+end_exe

N.b. we already account for the impossibility of anaphora in the following discourse, due to the universal presupposition introduced by the pronoun.[fn:2]

#+name: pronoun
#+begin_exe
\ex Either there's a\(_v\) bathroom, or there isn't a bathroom.\\
??It\(_v\)'s upstairs.
#+end_exe

* Integrating epistemic modality and EDS

EDS can be framed as an update semantics quite easily. Let's start with first-order EDS.

** First order EDS

A concise presentation of EDS as a semantics for a first order calculus.

#+name: def:eds-stat
#+begin_exe
\ex Static semantics for atomic sentences:\\
\([P(v_1,\ldots,v_n)]^{w,g} = \begin{cases} \mathbf{defined} &  g(v_1), \ldots ,g(v_n) \neq \#_e\\
\mathbf{true} & [P(v_1,\ldots,v_n)]^{w,g}\text{ is \textbf{defined} and }\langle g(v_1),\ldots,g(v_n)\rangle \in I_w(P)
\end{cases}\)
#+end_exe

#+name: def:eds-atom
#+begin_exe
\ex Atomic sentences in EDS:\\
\(\begin{aligned}[t]
&\eval*[w][+]{P(v_1,\ldots,v_n)} := \set{(g,h)|g = h \wedge |P(v_1,\ldots,v_n)|^{w,h}\text{ is \textbf{true}}}\\
&\eval*[w][-]{P(v_1,\ldots,v_n)} := \set{(g,h)|g = h \wedge |P(v_1,\ldots,v_n)|^{w,h} \text{ is \textbf{false}} }\\
&\eval*[w][u]{P(v_1,\ldots,v_n)} := \set{(g,h)|g = h \wedge |P(v_1,\ldots,v_n)|^{w,g}\text{ is \textbf{undefined}} }
\end{aligned}\)
#+end_exe

#+name: def:eds-neg
#+begin_exe
\ex Negative sentences:\\ 
\(\begin{aligned}[t]
&\eval*[w][+]{\neg \phi } := \eval*[-]{\phi }\\
&\eval*[w][-]{\neg \phi } := \eval*[+]{\phi }\\
&\eval*[w][u]{\neg \phi } := \eval*[u]{\phi }\\
\end{aligned}\)
#+end_exe

#+name: def:eds-conk
#+begin_exe
\ex Conjunctive sentences:\\
\(\begin{aligned}[t]
&\eval*[w][+]{\phi \wedge \psi} := \eval*[w][+]{\phi } \circ \eval*[w][+]{\psi}\\
&\eval*[w][-]{\phi \wedge \psi} := \begin{aligned}[t]
&\eval*[w][-]{\phi} \circ \eval*[w][+,-,u]{\psi}\\
&\cup \eval*[w][+,u]{\phi} \circ \eval*[w][-]{\psi}
\end{aligned}\\
&\eval*[w][u]{\phi \wedge \psi} := \begin{aligned}[t]
&\eval*[w][+]{\phi } \circ \eval*[w][u]{\psi}\\
&\cup \eval*[w][u]{\phi } \circ \eval*[w][+,u]{\psi}
\end{aligned}
\end{aligned}\)
#+end_exe

#+name: def:eds-rand
#+begin_exe
\ex Random assignment:\\
\(\begin{aligned}[t]
&\eval*[w][+]{\varepsilon_v} := \set{(g,h)|g[v]h}\\
&\eval*[w][-]{\varepsilon_v} := \emptyset\\
&\eval*[w][u]{\varepsilon_v} := \emptyset 
\end{aligned}\)
#+end_exe

#+name: def:eds-dag
#+begin_exe
\ex Positive closure:\\
\(\begin{aligned}[t]
&\eval*[w][+]{\dag\phi } := \eval*[w][+]{\phi}\\
&\eval*[w][-]{\dag\phi } := \set{(g,h)|g = h \wedge \eval*[w][+]{\phi } = \emptyset \wedge \eval*[w][-]{\phi } \neq \emptyset }\\
&\eval*[w][u]{\dag\phi } := \eval*[w][u]{\dag}\\
\end{aligned}\)
#+end_exe

To appreciate the isomorphism between this presentation, and the previous presentation, consider that a trivalent relational semantics can be framed instead as a set of relations, each paired with one of three truth values.

** Lifting EDS into an update semantics

As usual, we'll model information states using Heimian files, supplemented with a failure state \(\#_c\).

EDS can be lifted into a multivalent update semantics, where we define \(c[.]_+\), \(c[.]_-\), and \(c[.]_u\).

#+name: eds:bridge
#+begin_exe
\ex 
\begin{xlist}
\ex \(c[\phi]_+ := \bigcup\limits_{(w,g) \in c}\set{(w,h)|(g,h) \in \eval*[w][+]{\phi }}\)
\ex \(c[\phi]_- := \bigcup\limits_{(w,g) \in c}\set{(w,h)|(g,h) \in \eval*[w][-]{\phi }}\)
\ex \(c[\phi]_u := \bigcup\limits_{(w,g) \in c}\set{(w,h)|(g,h) \in \eval*[w][u]{\phi }}\)
\end{xlist}
#+end_exe

** EDS as an update semantics

*** Atomic sentences

Atomic sentences in EDS update semantics induce a tripartition of the input file, since no anaphoric information can be introduced. 

#+name: upd:atomic
#+begin_exe
\ex \(c[P(v_1,\ldots,v_n)]_+ := \set{(w,g) \in  c||P(v_1,\ldots,v_n)|^{w,g}\text{is \textbf{true}} }\)
\ex \(c[P(v_1,\ldots,v_n)]_- := \set{(w,g) \in  c||P(v_1,\ldots,v_n)|^{w,g}\text{is \textbf{false}} }\)
\ex \(c[P(v_1,\ldots,v_n)]_u := \set{(w,g) \in  c||P(v_1,\ldots,v_n)|^{w,g}\text{is \textbf{undefined}} }\)
#+end_exe

*** Negative sentences

#+name: upd:neg
#+begin_exe
\ex \(c[\neg\phi]_+ := c[\phi]_-\)
\ex \(c[\neg\phi]_- := c[\phi]_+\)
\ex \(c[\neg\phi]_u := c[\phi]_u\)
#+end_exe

*** Conjunctive sentences

#+name: upd:conj
#+begin_exe
\ex \(c[\phi \wedge \psi]_+ := c[\phi]_+[\psi]_+\)
\ex \(c[\phi \wedge \psi]_- := \begin{aligned}[t]
&c[\phi]_-[\psi]_+ \cup c[\phi]_-[\psi]_- \cup c[\phi]_-[\psi]_u\\
&c[\phi]_+[\psi]_- \cup c[\phi]_u[\psi]_-
\end{aligned}\)
\ex \(c[\phi \wedge \psi]_u := \begin{aligned}[t]
&c[\phi]_+[\psi]_u\\
&c[\phi]_u[\psi]_+ \cup c[\phi]_u[\psi]_u
\end{aligned}\)
#+end_exe

*** Random assignment

#+name: upd:rand
#+begin_exe
\ex \(c[\varepsilon_v]_+ := \set{(w,h)|\exists g[(w,g) \in c \wedge g[v]h]}\)
\ex \(c[\varepsilon_v]_- := \emptyset \)
\ex \(c[\varepsilon_v]_- := \emptyset \)
#+end_exe

*** Closure

#+name: upd:clo
#+begin_exe
\ex \(c[\dag\phi]_+ := c[\phi]_+\)
\ex \(c[\dag\phi]_- := \set{(w,g) \in c | c[\phi]_+ = \emptyset \wedge c[\phi]_- \neq \emptyset }\)
\ex \(c[\dag\phi]_u := c[\phi]_u\)
#+end_exe

*** Test semantics

Let's stick to Veltman's idea that a modalized statement, if true, adds no information to the CG.

#+name: upd:test
#+begin_exe
\ex /Might/ (first attempt):
\begin{xlist}
\ex \(c[\Diamond\phi]_+ := \set{(w,g) \in c| c[\phi]_+ \neq \emptyset }\)
\ex \(c[\Diamond\phi]_- := \set{(w,g) \in c | c[\phi]_+ = \emptyset \wedge c[\phi]_- \neq \emptyset }\)
\ex \(c[\diamond\phi]_u := c[\phi]_u\)
\end{xlist}
#+end_exe

By definition, modalized sentences are /tests/ on information states (they can't introduce any anaphoric information).

*** Pragmatics

What kind of bridge principle do we want for a trivalent update semantics?

#+begin_definition
*Assertion*. An assertion of \(\phi \) in \(c\), \(c[\phi]\), is defined as follows:

\[c[\phi] := \begin{cases}
c[\phi]_+&c[\phi]_u = \emptyset\\
&\#_c&\text{otherwise} 
\end{cases}\]
#+end_definition

*** An alternative semantics for /might/ 

Let's start by specifying the positive contribution of /might/.

#+name: upd:test
#+begin_exe
\ex /Might/ (first attempt):
\begin{xlist}
\ex \(c[\Diamond\phi]_+ := \begin{cases}
c[\phi]_+ \cup c[\phi]_-&c[\phi]_+ \neq \emptyset\\
\emptyset&\text{otherwise} 
\end{cases}\)
\end{xlist}
#+end_exe

We'll come back to the negative update associated with \(\diamond\phi \).

*** Bathrooms and contextual entailment

This has the virtue of accounting for a variant of Rothshchild discourses involving epistemic modals.

#+name: critic
#+begin_exe
\ex Context: /It's common ground that a restaurant critic will be here on Monday, but it's not common ground what day it is./
\begin{xlist}
\ex A: It's possible that a restaurant critic is here.
\ex B: It's Monday, so they\(_v\)'re here right now.
\end{xlist}
#+end_exe

#+name: poss-critic
#+begin_exe
\ex 
\begin{xlist}
\ex It's possible that a restaurant critic is here.
\ex \(\Diamond (\exists_v[C(v)])\)
\end{xlist}
#+end_exe

#+name: poss
#+begin_exe
\ex \(c[\Diamond(\exists_v[C(v)])]_+ = \begin{cases}
c[\neg\exists_v[C(v)]]_+\cup c[\exists_v[C(v)]]_+& \exists w\in c[ I_w(C) \neq \emptyset]\\
\emptyset & \text{otherwise}
\end{cases}\) 
#+end_exe

In plain English, "it's possible that a\(^v\) critic is here" is an instruction to take a file \(c\), and:

- Check that there is at least one world where a critic is here (Veltman's consistency test).
- Update \(c\) with the information that there is a critic \(v\), giving back \(c'\).
- Update \(c\) with the information that there is no critic, giving back \(c''\).
- Return \(c \cup c'\).

If a subsequent update eliminates all non-critic worlds in \(c'\), then anaphora may subsequently be licensed (since familiarity will be satisfied).

*** Conjunctive possibilities

The following is an acceptable sentence.

#+name: 
#+begin_exe
\ex There might be no\(^v\) bathroom and it\(_v\) might be upstairs.
#+end_exe

Let's compute the positive contribution of the first sentence.

#+name: poss
#+begin_exe
\ex \(c[\Diamond(\neg\exists_v[B(v)])]_+ = \begin{cases}
c[\neg\exists_v[B(v)]]_+\cup c[\exists_v[B(v)]]_+& \exists w\in c[ I_w(B) = \emptyset]\\
\emptyset & \text{otherwise}
\end{cases}\) 
#+end_exe

This update ensures that \(c\) is consistent with their being no bathroom, and pairs bathroom worlds with bathroom drefs, and leaves non-bathroom worlds unchanged.

Let's move on to the second sentence.

#+name: poss-bath2
#+begin_exe
\ex It\(_v\) might be upstairs.
\ex \(\Diamond(U(v))\)
#+end_exe

This update ensures that \(c\) is consistent with \(v\) being upstairs, and simply returns the union of the \(v-\)upstairs and \(v\)-not-upstairs worlds.

#+name: poss2
#+begin_exe
\ex \(c[\Diamond(U(v))]_+ = \begin{cases}
c[U(v)]_+ \cup c[U(v)]_-&c[U(v)]_+ \neq \emptyset\\
\emptyset &\text{otherwise} 
\end{cases} \)
#+end_exe

We can now think through, what happens when we chain these updates together. That's pretty easy for conjunction.

#+name: chain
#+begin_exe
\ex \(c[\Diamond(\neg\exists_v[B(v)]) \wedge \Diamond(U(v))]_+ = c[\Diamond(\neg\exists_v[B(v)])]_+[\Diamond(U(v))]_+\)
#+end_exe

#+begin_warningblock
Oh no! something has gone wrong here. Concretely, the update expressed by the second sentence requires that the familiarity presupposition is met /throughout/ the input context. If the test imposed by the first epistemic modal is successful, there are guaranteed to be worlds in which there are no bathrooms, and the second update will fail.
#+end_warningblock






* References

#+print_bibliography:

* Appendices

** Attempt 1: inquisitive semantics (doesn't work)

The structure introduced by disjunction needs to be retained.

Intuition:

- /might \(p\)/ tests at \(c\) whether \(p\) is consistent, *and* introduces two /alternatives/: \(c[p]_+\) and \(c[p]_-\). The second modalized conjunct is interpreted just relative to the second alternative.
  
Problem:

#+name: mod
#+begin_exe
\ex ???There might be no\(^v\) bathroom, and it\(_v\)'s upstairs.
#+end_exe

** Attempt 2: Modal subordination (doesn't work nicely)

See [cite:@Kibble1994].

Evidence that this might be on the right track:

#+name: would
#+begin_exe
\ex There might be no\(^v\) bathroom, but it would be upstairs.
#+end_exe

** Attempt 3: Individual concepts (isn't necessary)

See [cite:@Hofmann2019]. Shifting to an update semantics might allow us to make sense of this. Let's try it!!!

*** Analysis

Random assignment introduces an /individual concept/ discourse referent \(v\).

/Assignments/ are total functions from variables to /individual concepts/.

/Individual concepts/ are partial functions from worlds to individuals.

#+name: upd2:rand
#+begin_exe
\ex \(c[\varepsilon_v]_+ := \set{(w,h)|\exists g[(w,g) \in c \wedge g[v]h]}\)
\ex \(c[\varepsilon_v]_- := \emptyset \)
\ex \(c[\varepsilon_v]_- := \emptyset \)
#+end_exe

Pronouns presuppose that their extension is non-impossible at the world of evaluation.

All we really need to do to accomplish this is to slightly modify our static semantics.

#+name: def2:eds-stat
#+begin_exe
\ex Static semantics for atomic sentences:\\
\([P(v_1,\ldots,v_n)]^{w,g} = \begin{cases} \mathbf{defined} &  g(v_1)(w), \ldots ,g(v_n)(w) \neq \#_e\\
\mathbf{true} & [P(v_1,\ldots,v_n)]^{w,g}\text{ is \textbf{defined} and }\langle g(v_1),\ldots,g(v_n)\rangle \in I_w(P)
\end{cases}\)
#+end_exe

In extensional EDS, we could decompose existential quantification into random assignment, conjunction, and a closure operator \(\dag\). In an intensional setting, we need a slightly more involved semantics for closure.

#+name: int:ex
#+begin_exe
\ex \(c[\exists_v\phi]_+ := c[\varepsilon_v]_+[\phi]_+\)
#+end_exe

#+begin_tipblock
We need to somehow ensure that the individual concept maps worlds in which there is no witness to the impossible individual.
#+end_tipblock

** An example to work through (meh)

Consider the following logical space (indices indicate an existing bathroom).



Given two individuals \(1,2,\#_e\), there are \(3^4\) (\(81\)) possible individual concepts mapping worlds to individuals.

We want "a\(^v\) bathroom" to introduce the following two individual concepts at variable \(v\): 

1. \([w_{12} \to 1, w_1 \to 1, w_2 \to 2, w_\emptyset \to \#_e]\)
2. \([w_{12} \to 2, w_1 \to 1, w_2 \to 2, w_\emptyset \to \#_e]\)
   
Note that (I think) this allows to keep track of worldly information, and anaphoric information independently.

Let's treat assignments as functions from /variable-world pairs/ to individuals.

\[
\set{w_{12},w_1,w_2,w_\emptyset } \ast \Set{\left[\begin{aligned}[c]
&v_{w_{12}} \to 1\\
&v_{w_1} \to 1\\
&v_{w_2} \to 2\\
&v_{w_\emptyset} \to \#_e
\end{aligned},\right]_{g_1}, \left[\begin{aligned}[c]
&v_{w_{12}} \to 2\\
&v_{w_1} \to 1\\
&v_{w_2} \to 2\\
&v_{w_\emptyset } \to \#_e
\end{aligned},\right]_{g_2}}\]

Here we have a set of worlds paired with a set of assignments mapping variables to functions from worlds to bathrooms in those worlds. 

Let's say that individual concepts are partial functions from worlds to individuals, we can then define the notion of /concept modification/.

The initial information state:

\(\set{w_{12},w_1,w_2,w_\emptyset } \ast \Set{\left[\begin{aligned}[c]
v_{w_{12}} \to \#_e\\
v_{w_{1}} \to \#_e\\
v_{w_{2}} \to \#_e\\
v_{w_{\emptyset }} \to \#_e\\
\end{aligned}\right]}\)

Equivalently, if we think explicitly in terms of partial assignments:


\(\set{w_{12},w_1,w_2,w_\emptyset } \ast \Set{\left[]}\)

Now, "There is a\(^v\) bathroom" should (a) eliminate non-bathroom worlds (\(w_\emptyset \)) and indeterministically extend variable-world pairs to bathrooms in that world. 

\[\set{w_{12},w_1,w_2} \ast \set{[v_{12} \to 1, v_{1} \to 1, v_2 \to 2],[v_{12} \to 2, v_1 \to 1, v_2 \to 2]}\]

let's call the initial information state \(\phi \ast \psi\).

\[(\phi \ast \psi)[\text{a}^v\text{ bathroom}] := \set{w | w \in \phi \wedge I_w(B) \neq \emptyset } \ast \set{h | \exists g[g \in \psi \wedge g[v_w]h \wedge h(v_w) \in I_w(B)]}\]

\[= \set{w_{12},w_1,w_2} \ast \set{[v_{12} \to 1, v_{1} \to 1, v_2 \to 2],[v_{12} \to 2, v_1 \to 1, v_2 \to 2]}\]

Now let's call this new information state \(\phi' \ast \psi'\), and let's assume that only bathroom \(1\) is ever upstairs in any given world.

\((\phi' \ast \psi')[\text{it}^1\text{ is upstairs}] = \set{w_{12},w_1} \ast \set{[v_{12} \to 1, v_1 \to 1, v_2 \to 2]}\)

This becomes difficult to state, because we're breaking the link between the worldly and anaphoric information. Let's try to do this in a distributive fashion.

** Distributive analysis (no)

- Worlds are integers \(w_1, w_2, \ldots\).
- Assignments are partial functions from /variable-world pairs/ (\(x_1 := (x,w_1)\)) to individuals \(a,b,c,\ldots\)
- Meanings are functions from /world-assignment pairs/ to sets of assignments.
  
OK, for pronouns this might work: pronouns can introduce discourse referents.  

\(\eval*[+]{\text{she}_v\text{ left}} := \lambda (w,g)\,.\set{g | g(v_w) \neq \# \wedge   g(v_w) \in I_w(L)}\)

\(\eval*[-]{\text{she}_v\text{ left}} := \lambda (w,g)\,.\set{g^{[v_w \to \#]} |g(v_w) \neq \# \wedge  g(v_w) \notin I_w(L)}\)

\(\eval*[u]{\text{she}_v\text{ left}} := \lambda (w,g)\,.\,\set{g | g(v_w) = \#}\)

Now, I think we can treat indefinites as plain old random assignment:

\(\eval*[v]{\text{someone} }^+ := \lambda (w,g)\,.\,\set{g^{[v_n \to x]} | x \in D, n \in W}\)

** TODO A sketch of how it should work (Keep going from here)

- "Maybe there is a\(^v\) bathroom" asserts that there are some worlds in which there is a bathroom, and in those worlds \(w\) \(v_w\) is a bathroom, and some worlds with no bathroom \(w'\), where \(v_w'\) is undefined.
- "Maybe there is no\(^v\) bathoom" asserts that there are some worlds in which there is no bathoom; in those worlds \(w\), \(v_w\) is undefined, and some worlds with a bathroom \(w'\); in those worlds \(v_w'\) is a bathroom.
- "Maybe it's upstairs" asserts that there are some worlds \(w\) in which \(v_w\) is defined and upstairs, and some worlds \(w'\) in which \(v_w'\) is defined and not upstairs. This is validated just by those worlds in the complement set from the previous update. 

#+name: maybe1
#+begin_exe
\ex Maybe there's no\(^v\) bathroom.
\ex \(\lambda c\,.\,\begin{cases}
c \cup c'[\text{no bathroom}] \cup c'[\text{not no}^v\text{ bathroom} ]&\exists c' \subseteq c[c'[\text{no bathroom}] \neq \emptyset]\\
\text{undefined}&\text{otherwise}  
\end{cases}\)
\ex Maybe it's upstairs.
\ex \(\lambda c\,.\,\begin{cases}
\dots & \exists c'' \subseteq c[c''[]]
\end{cases}\)
#+end_exe

A trivial modification of Veltman (could we do this relative to individual slices?):

#+name: mightnew
#+begin_exe
\ex \(c[\Diamond\phi] := \begin{cases}
c& \exists c' \subseteq c[c'[\phi] \neq \emptyset]\\
\emptyset & \text{otherwise} 
\end{cases}\)
#+end_exe

- If \(c \cap p \neq \emptyset \), then \(\exists p' \subseteq p[c \cap p' \neq \emptyset]\) (this definitely goes through).
- If \(\exists c' \subseteq c[c' \cap p \neq \emptyset]]\), then \(c \cap p \neq \emptyset \) ? This goes through too.
  
\(c \cap p \neq \emptyset \iff \exists p' \subseteq p[c \cap p' \neq \emptyset]\)



* Footnotes

[fn:2] Given partial assignments, a standard bridge principle predicts that \(v\) should be defined at /every/ assignment in the file context.

[fn:1] There's a subtlety here involving the novelty condition and downdate that we're glossing over here. Can you  spot it?

* File local variables                                             :noexport:
 
# Local Variables:
# mode: org
# org-latex-default-packages-alist: nil
# org-latex-with-hyperref: nil
# End:

