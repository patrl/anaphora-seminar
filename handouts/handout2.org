#+title: From FCS to DPL (and back again)
#+author: Patrick D. Elliott 
#+bibliography: ../../bibliography/master.bib
#+setupfile: handout-template.org
#+OPTIONS: ':t
#+cite_export: biblatex

* Introduction

** Next week

Rethinking dynamic semantics as a /compositional/ theory of meaning (recall /discourse referents *inside* and out/).

- *Obligatory reading*: Simon Charlow's recent paper "Static and dynamic exceptional scope" [cite:@Charlow2020]. 
- *Optional readings*
  * Part I of Charlow's 2014 dissertation "On the semantics of exceptional scope" [cite:@Charlow2014].
  * Groenendijk and Stokhof's 1990 paper "Dynamic Montague Grammar" [cite:@GroenendijkStokhof1990].
    
** This week

- More on File Change Semantics.
- Shifting gears: Dynamic Predicate Logic.
- Refactoring FCS as a distributive system, using ideas from DPL.
- Along the way, we'll discuss empirical issues for the treatment of logical operators in FCS/DPL.

* FCS

** Contexts, assignments, and variables

#+name: def:contexts
#+begin_definition
Contexts and assignments.

- A (file) context \(c\) is a set consisting of world-assignment pairs. 
- An /assignment/ is a total function from variables to individuals.
#+end_definition

Our starting point: Heim's intensional notion of novelty/familiarity.

#+name: def:novelty
#+begin_definition
A variable \(x\) is /novel/ with respect to a context \(c\), iff:

\[\mathbf{nov}_c(x) := \forall g,g',w[g[x]g' \rightarrow ((w,g) \in c \iff (w,g'))]\]

Otherwise, \(x\) is /familiar/ with respect to \(c\), \(\mathbf{fam}_x(c)\).

N.b. /familiarity/ is persistent, i.e., if \(\mathbf{fam}_c(x)\), then for any \(c' \subseteq c\), \(\mathbf{fam}_x(c')\).
#+end_definition

Core thesis of FCS: Both indefinite and definite DPs are interpeted as /variables/.

- Indefiniteness imposes a novelty check on the input context.
- Definiteness imposes a familiarity check on the input context.

#+name: ex:woman
#+begin_exe
\ex A^x woman walked in. \(\Rightarrow \lambda c:\mathbf{nov}_c(x)\,.\,\set{(w,g) \in c|\mathbf{womanWhoWalkedIn}_w(g_x)}\)
\ex She_x sat down. \(\Rightarrow \lambda c:\mathbf{fam}_c(x)\,.\,\set{(w,g) \in c | \mathbf{satDown}_w(g_x)}\)
#+end_exe

#+name: def:heim-bridge
#+begin_definition
Heim's bridge principle. An assertion of sentence \(\phi\) in a context \(c\), if accepted, gives rise to an updated context \(c[\phi]\), defined as follows:

\[c[\phi] := \eval*{\phi}(c)\]
#+end_definition

** Example 1: discourse anaphora

A concrete example. Let's consider the flow of information in the following discourse:

#+name: ex:womagain
#+begin_exe
\ex A^x woman walked in; she sat down.
#+end_exe

- \(w_\emptyset\): neither walked in nor sat down.
- \(w_a\): \(a\) walked in and sat down; \(b\) did neither.
- \(w_a'\): \(a\) walked and didn't sit; \(b\) didn't walk in but did sit down.
- \(w_b\): \(b\) walked in and sat down; \(a\) did neither.
- \(w_b'\): \(b\) walked in and sat down; \(a\) didn't walk in but did sit.
- \(w_ab\): \(a\) and \(b\) both walked in and sat down.
  
Variables: \(x,y\). The initial context is the Cartesian product of logical space and the set of assignments \(g: \set{x,y} \to \set{a,b}\).

\[c_0 = \Set{\begin{array}{c}
\left(w_\emptyset,\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_\emptyset,\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right),\left(w_\emptyset,\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_\emptyset,\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\left(w_a,\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_a,\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right),\left(w_a,\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_a,\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\left(w_{a'},\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_{a'},\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right),\left(w_{a'},\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_{a'},\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\left(w_b,\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_b,\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right),\left(w_b,\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_b,\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\left(w_{b'},\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_{b'},\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right),\left(w_{b'},\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_{b'},\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\left(w_{ab},\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\end{array}}
\]

Update with "A^x woman walked in".

- Novelty is trivially satisfied.
- We eliminate any \((w,g)\), where \(g\) maps \(x\) to a woman who didn't walk in, in \(w\).

\[c_{1} = \Set{\begin{array}{c}
\left(w_a,\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_a,\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right)\\
\left(w_{a'},\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_{a'},\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right)\\
\left(w_b,\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_b,\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\left(w_{b'},\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_{b'},\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\left(w_{ab},\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\end{array}}
\]

Now let's update \(c_1\) with "She_x sat down".

- First, to check whether or not the update is defined, we check if \(x\) is familiar.
- All that's necessary to show that \(x\) is familiar is to find some world \(w\) which discriminates between assignments that differ only at \(x\). There are plenty to choose from, but consider \(w_a\), which is paired with \([x \to a, y \to a]\) but not \([x \to b, x \to a]\).
- Now we eliminate any \((w,g\), where \(g\) maps \(x\) to a woman who didn't sit down.

\[
c_{2} = \Set{\begin{array}{c}
\left(w_a,\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_a,\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right)\\
\left(w_b,\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_b,\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\left(w_{b'},\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_{b'},\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\left(w_{ab},\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\end{array}}
\]

We're left just with the worlds in which someone walked in and sat down.

- In \(w_a\), it's \(a\) who did so, so \(w_a\) is paired with assignments that map \(x\) to \(a\).
- In \(w_b\), it's \(b\) who did so, so \(w_b\) is paired with assignments that map \(x\) to \(b\).
- In \(w_{ab}\), it's both \(a\) and \(b\) who did so, so \(w_{ab}\) is paired with assignments that map \(a\) to \(b\) and assignments that map \(x\) to \(b\).
  
Note, \(c_2\) is only true at worlds where the same woman both walked in and sat down.

Let's double check that \(y\) still isn't familiar in \(c_2\) (remember, we only consider assignments which differ minimally wrt \(y\)).

** Example 2: concurrent indefinites 

Round two. Consider the following discourse:

#+name: ex:awomantwice
#+begin_exe
\ex A^x woman walked in. A^y woman sat down.
#+end_exe

We already know what happens when we update the initial context with the first sentence, we get \(c_1\). We know that \(y\) is /novel/ in \(c_1\), so let's update \(c_1\) with "A^y woman sat down".

- We eliminate any \((w,g)\), where \(g\) maps \(y\) to a woman who didn't sit down.

\[c_{3} = \Set{\begin{array}{c}
\left(w_a,\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right)\\
\left(w_{a'},\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right)\\
\left(w_b,\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\left(w_{b'},\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_{b'},\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\left(w_{ab},\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right]\right),\left(w_{ab},\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]\right)\\
\end{array}}\] 

\(c_3\) is true at worlds where the same individual both walked in and sat down (\(w_a, w_b, w_b', w_{ab}\)), but also worlds in which distinct individuals walked in and sat down (\(w_a'\)).

FCS therefore doesn't derive /disjoint reference/ out of the box, for concurrent, contra-indexed indefinites.

** Disjoint reference in FCS

What is the nature of the putative disjoint reference inference?

#+name: ex:disjoint2
#+begin_exe
\ex A woman walked in; a woman sat down. In fact, I later discovered that it was the same woman.
#+end_exe

#+name: ex:disjoint
#+begin_exe
\ex context: /the speaker is knows that that the same woman walked in and sat down, but isn't sure which woman walked in and sat down./
\ex ?? A^x woman walked in; A^y woman sat down.
\ex A^x woman walked in; she_x sat down.
#+end_exe

These facts suggest that disjoint reference should be derived as a /primary implicature/ (in the sense of [cite:@Sauerland2004]), i.e., the speaker is not certain that \(x\) and \(y\) are mapped to same individual. 

In fact, this can be derived via a familiar Gricean reasoning process if the following are alternatives:

- "A^x woman walked in and the\(_x\) woman/she\(_x\) sat down".
- "A^x woman walked in and a woman\(^y\) sat down" (for any variable \(y \neq x\))

The latter is contextually more informative than the former.  

We can easily formalize /contextual informativity/ in FCS as follows (definition from [cite:@Sudo2022]):

#+begin_definition
Contextual informativity. A sentence \(\phi\) is /contextually more informative/ than a sentence \(\psi\) with respect to a context \(c\) iff:

\[\mathbf{W}(c[\phi]) \subset \mathbf{W}(c[\psi])\] 
#+end_definition

- Upon hearing "A^x woman walked; a^y woman sat down", the hearer notices an alternative "A^x woman walked in; the^y woman sat down", which would have been contextually more informative.
- The speaker didn't assert the alternative, so they must not be certain that it's true.
- A stronger, secondary implicature could be derived pragmatically [cite:@Sauerland2004], or via an exhaustification operator geared to act on CCPs [cite:@Fox2007].

Note that the judgement is that concurrent indefinites result in /oddness/ in the context given in ([[ex:disjoint]]), which isn't necessarily expected on a pragmatic account. 

This can arguably be understood as a special case of a phenomenon that applies to scalar implicatures more generally [cite:@Magri2009].

An apparent problem for this account is that it predicts an (unattested?) scalar inference for definites under negation (assuming alternativehood is symmetric).

#+name: yasu1
#+begin_exe
\ex A^x woman and a dog walked in; nobody saw the_x woman.<<yasu-1a>>
\ex A^x woman and a dog walked in; nobody saw a^y woman.<<yasu-1b>>
#+end_exe

([[yasu-1a]]) doesn't seem to imply that someone saw a woman who didn't walk in(?).[fn:12]

** Informational vs. dynamic redunancy

A contrast noted by Filipe last week:

#+begin_exe
\ex A^x woman walked in; A^y woman sat down.<<ex:redunancy1>>
\ex ??A^x woman walked in; A^y woman walked in.<<ex:redundancy2>>
#+end_exe

Why does ([[ex:redunancy1]]) sound OK (and give rise to a disjoint reference inference), whereas ([[ex:redundancy2]]) sounds odd?

Conjecture: despite being /dynamically informative/, the second assertion in ([[ex:redundancy2]]) is /informationally redundant/. 

#+name: redundancy
#+begin_exe
\ex /Principle of non-redundancy:/ an assertion is infelicitous if it is redundant.
#+end_exe

We can define a number of different notions of redundancy within FCS. Here are two:

#+begin_definition

*Informational redundancy*. Assertion of \(\phi \) with respect to a context \(c\) is /informationally redundant/ iff:

\[\mathbf{W}(c[\phi]) = \mathbf{W}(c)\]
#+end_definition

#+begin_definition
*Dynamic redundancy*. Assertion of \(\phi \) with respect to a context \(c\) is /dynamically redundant/ iff:

\[c[\phi] = c\]
#+end_definition

Now, consider again our odd example, "A^x woman walked in. A^y woman walked in".

- The second assertion isn't /dynamically/ redundant, since it cuts our world-assignment pairs where \(y\) gets mapped to someone who isn't a woman that walked in.
- It is, however, /informationally/ redundant, since the informational contribution is the same as the first assertion.
- Note that the second assertion may not be informationally redundant if it were guaranteed that \(x \neq y\) (e.g., via a disjointness inference).
  + The disjointness inference can't be derived in the same way as before, since the alternative "A^x woman walked in; the woman_x walked in" also gives rise to a violation of the principle of redundancy.
    
Conjecture: in natural language, dynamic informativity (e.g., introducing a discourse referent) isn't enough to obviate informational redundancy - the /principle of redundancy/ should be understood relative to informational redundancy.

An aside: this finding addresses a potential issue with the Heimian notion of /novelty/, which predicts that tautological statements can't introduce discourse referents.

#+name: ex:taut
#+begin_exe
\ex Something^x is self-identical; it_x is John.
#+end_exe

There are two possibilities for ([[ex:taut]]):

- Everything is self-identical, therefore "Something\(^x\) is self-identical" is informationally trivial and violates the principle of non-redundancy for any context.
- There is a way of understanding "Something\(^x\) is self-identical" which renders it informationally informative, in which case \(x\) becomes familiar and anaphora is possible.
  
Such sentences therefore don't seem to pose a serious threat to the Heimian notion of novelty/familiarity, contra [cite:@Heim1982].

** A loose end: definite descriptions

Recall that pronouns are variables with a /familiarity/ presupposition.

We haven't said anything concrete yet about definite descriptions, but FCS very naturally accounts for definite descriptions in the following way, e.g., for "the_x woman sat down.":

#+name: ex:definite
#+begin_exe
\ex \(\lambda c\,.\,\begin{cases}
\set{(w,g) \in c\,.\,\mathbf{satDown}_w(g_x)}&\forall(w,g) \in c[\mathbf{woman}_w(g_x)]\\
\text{undefined}&\text{else}  
\end{cases}\)
#+end_exe

This accounts for the fact that definites behave like pronouns with an indefinite antecedent (we tailor our example here to show that uniqueness isn't required):

#+name: ex:definite
#+begin_exe
\ex A^x woman walked in; The_x woman sat down with another woman.
#+end_exe

- Updating \(c\) with the first sentence eliminates world assignment pairs \((w,g\), where \(g_x\) isn't a woman who walked in in \(w\). 
- Updating with the second sentence is defined iff every world assignment pair \((w,g\) in the input is s.t. \(g_x\) is a woman.
- The requirement is satisfied, so now we eliminate \((w,g)\)s where \(g_x\) didn't sit down with another woman in \(w\).
 - Note that the presupposition of a definite description is a strictly stronger requirement than familiarity /per se/.
   
We can account for \(\phi \)-features in a parallel fashion. A putative CCP for "She_x sat down" (\(\phi \)-features systematically give rise to presuppositions that must be accommodated on this view):

#+name: ex:phi
#+begin_exe
\ex \(\lambda c\,.\,\begin{cases}
\set{(w,g) \in c| \mathbf{satDown}_w(g_x)}&\forall (w,g) \in c[\mathbf{prefersSheHer}_w(g_x)]\\
\text{undefined}&\text{else}  
\end{cases}\)
#+end_exe

A problem with the approach to definite descriptions in FCS (the /familiarity theory/ of definiteness) is that it fails to account for uniqueness inferences.

After all, there's a reason people believed that /uniqueness/ is entailed by definite descriptions (the examples here are a variant of data discussed by [cite:@MandelkernRothschild2020]).

#+name: date
#+begin_exe
\ex John went on a date; he liked the\(_x\) woman, so he planned to see her\(_x\) again.
#+end_exe

#+name: date2
#+begin_exe
\ex John went on dates with a few different women; ??he liked the\(_x\) woman, so he planned to see her\(_x\) again.
#+end_exe

- In sum, FCS (and dynamic theories more generally) do excellently in accounting for the fact that definites don't require uniqueness if they have an indefinite antecedent.
- As it stands however, it is mysterious why definites require uniqueness when they don't have an antecedent. As emphasized by [cite:@MandelkernRothschild2020], this is arguably a question of /accommodation/ - in fact, the logic is similar to the proviso problem.

** Dynamic conjunction 

We haven't yet been concrete about what conjunction means in FCS.

Recall that /novelty-familiarity/ is crucially defined relative to /files/ rather than individual evaluation points.

There's no way to determine, just by looking at individual evaluation points, whether or not a variable is novel with respect to the file.

Since the novelty requirement is taken to be induced by a linguistic feature of particular sentences - (in)definiteness - there is apparently no escape from treating sentences as functions from files to files (i.e., CCPs).

We can define an operator to perform successive update. This turns out to just be function composition. We'll write it as \(;\), and it will play a prominent role in FCS.[fn:4][fn:7]

#+begin_definition
The dynamic sequencing operator \(;\).

\[p;q := \lambda F\,.\,q(p(F))\]
#+end_definition

At this point, it will be useful to give a type for a CCP; let's use \(T\). The dynamic sequencing operator is of type \(T \to T \to T\).

The sequencing operator famously serves as the meaning of conjunction in FCS. Assuming a standard Kaynean syntax for conjunction:

#+name: def:conj
#+begin_exe
\ex \(\text{and} \Rightarrow \lambda q\,.\,\lambda p\,.\,p ; q\)\hfill\(T \to T \to T\)
#+end_exe

A direct consequence of this definition is that successive update \(c[\phi][\psi]\) is exactly equivalent to \(c[\phi \text{ and }\psi]\). 

Since dynamic sequencing is just function composition, it inherits the logical properties of function composition, e.g., it is associative. This means we'll often omit parentheses when sequencing.

\[(\phi ; \psi) ; \pi \iff \phi ; (\psi ; \pi)\]

Both of the following are equivalent:

#+name: ex:assoc
#+begin_exe
\ex A\(^x\) man walked in and he\(_x\) sat down. He\(_x\) started fidgeting.
\ex A\(^x\) man walked in. He\(_x\) sat down and he\(_x\) started fidgeting.
#+end_exe

Similarly, dynamic sequencing is not necessarily commutative (although some CCPs commute). This reflects the fact that some CCPs can set up the preconditions for other CCPs to apply.

#+name: ex:comm
#+begin_exe
\ex A\(^x\) man walked in and he\(_x\) sat down.
\ex ?He\(_x\) walked in and a\(^x\) man sat down.<<ex:comm2>>
#+end_exe

FCS predicts the CCP of ([[ex:comm2]]) to be undefined for /any/ file context. 

It's often assumed that FCS (and dynamic semantics more generally) explains why discourse anaphora displays a left-to-right bias, as illustrated by ([[ex:comm]]).

#+begin_tcolorbox
It's important to note that all of the results stated so far must be assessed in light of a compositional proposal with sufficient resources for scope-taking. We'll come back to this in a couple of weeks time. 
#+end_tcolorbox

Before talking about subsentential compositionality (and donkey anaphora!) in FCS, we'll consider a partial variant of FCS.

* Partial FCS

** File contexts in partial FCS

Recall the apparent problem Heim observed with informationally trivial updates.

#+name: ex:contingent
#+begin_exe
\ex Something\(^x\) is identical to itself. It\(_x\) is John.
#+end_exe

As we've discussed, this arguably isn't a problem for the Heimian notion of novelty, due to the independently motivated pragmatic principle against redundant assertions. 

Nevertheless, Heim took this problem seriously. It is now common to adopt a variant of FCS which uses partial assignments, as suggested by Heim [cite:@Heim1983a]. See, e.g., [cite:@Dekker1996;@Yalcin2013;@RothschildMandelkern2017;@Mandelkern2020a;@Heim2017;@Elliott2020g].[fn:6][fn:10] 

N.b. this will also be essential for making FCS /distributive/, as we'll discuss following DPL.

A partial assignment is a /partial/ function from variables to individuals, i.e., a function whose domain is a subset of the stock of variables. This includes the empty/initial assignment \(g_\top  \), whose domain is the empty set. 

In a partial setting, its natural to model the initial/ignorance file context in the following way:

\[c_\top = W \times \set{g_\top}\]

In partial FCS, familiarity is cashed out as a universal requirement on the domains of assignments in the file context.

** Novelty and familiarity in partial FCS

#+begin_definition
Familiarity in partial FCS. 

\[\mathbf{fam}_c(x) \iff \forall(*,g) \in c[x \in \mathbf{dom}(g)]\]
#+end_definition

Novelty, just as before, is the other side of the same coin.

#+begin_definition
Novelty in partial FCS.

\(\mathbf{nov}_c(x) \iff \neg\ \mathbf{fam}_c(x)\)
#+end_definition

** (In)definiteness in partial FCS

Just as before, pronouns are interpeted as variables with a familiarity presupposition: the CCP for "she_x sat down":

#+name: ex:partial-pron
#+begin_exe
\ex \(\lambda c\,.\,\begin{cases}
\set{(w,g) \in c|\mathbf{satDown}_w(g_x)}&\mathbf{fam}_c(x)\\
\text{undefined}&\text{else}  
\end{cases}\)
#+end_exe

Indefinites are a little different, since they must extend the domain of assignments in the input context. The CCP for "A^x woman walked in":

#+name: ex:partial-indef
#+begin_exe
\ex \(\lambda c\,.\,\begin{cases}
\set{(w,g^{[x \to a]}) | (w,g) \in c \wedge  \mathbf{womanWalkedIn}_w(a)}&\mathbf{nov}_c(x)\\
\text{undefined}&\text{else}  
\end{cases}\)
#+end_exe

(Note: this is awfully similar to what we'll end up with as the semantics of existential quantifiers in DPL, modulo the novelty requirement)

There's a way of mapping FCS file contexts to partial FCS file contexts:

#+begin_definition
Mapping from an FCS file context \(c\) to a partial FCS file context.

\[\set{(w,g')|(w,g) \in c \wedge \forall v \in \mathbf{dom}(g)[(\mathbf{nov}_c(v) \rightarrow v \notin \mathbf{dom}(g')) \wedge (\mathbf{fam}_c(v) \rightarrow g_v = g'v)]}\]
#+end_definition

It can be shown that the CCPs provided for partial FCS correspond to mapping FCS contexts updated by our previous CCPS to partial FCS file contexts. I'll leave this as a homework exercise.

** Partial FCS is non-eliminative

One immediate consequence of this is that we lose an (appealing?) logical property of Heim's original FCS, which it shares with classical Stalnakerian pragmatics - /eliminativity/ [cite:@GroenendijkStokhof1991a].

#+begin_definition
\(\phi\) is /eliminative/ iff \(c[\phi] \subseteq c\), \(\forall c\)
#+end_definition

Sentenes with indefinites convey non-eliminative updates; in FCS proper all updates are eliminative.

This is important, since eliminativity plays an important role in characterizing exactly what it means for a semantics to be "dynamic", together with /distributivity/.

We'll talk more about this in a bit (Heim's FCS is eliminative but non-distributive; DPL is distributive but non-eliminative) [cite:@Benthem1989].

** Presupposition in partial FCS

Something interesting we can note about this partial variant: the novelty/familiarity presupposition is cashed out as a universal requirement on every evaluation point in the domain.

It seems tempting to treat sentences as being simply partial functions from /evaluation points/ to "files", allowing a Stalnakerian bridge principle to take care of the universal requirement on the file context. What we would end up with is a system where sentences denote something less expressive than a CCP.

Unfortunately this is incompatible with the semantics of logical vocabulary, and the account of donkey anaphora, which involve positing operators which operate on CCPs.

We'll resurrect this idea when we recast FCS as a distributive system, and again when we discuss a system I developed recently called /externally-dynamic dynamic semantics/ in a couple of weeks time [cite:@Elliott2020g].

* FCS as a theory of composition

We'll switch back to FCS proper now, although the partial variant will be mentioned from time to time. 

** The indefinite article

A remarkable property of FCS is that the indefinite article itself can be given a CCP (i.e., be treated as a sentence).

#+name: ex:ccp-indef
#+begin_exe
\ex \(\text{a}^x \Rightarrow \lambda c\,.\,\begin{cases}
c&\mathbf{nov}_c(x)\\
\text{undefined}&\text{else}  
\end{cases}\)\hfill\(T\)
#+end_exe

A natural consequence is a treatment of the restrictor and nuclear scope of a determiner as open formulas, just like sentences with pronouns.

#+name: ex:ccp-restrictorscope
#+begin_exe
\ex \(t_x\text{ man} \Rightarrow \lambda c: \mathbf{fam}_c(x)\,.\,\set{(w,g) \in c| \mathbf{man}_w(g_x)}\)
\ex \(t_x\text{ sat down} \Rightarrow \lambda c: \mathbf{fam}_c(x)\,.\,\set{(w,g) \in  c|\mathbf{satDown}_w(g_x)}\)
#+end_exe

By conjecture, dynamic sequencing is generally available as a composition principle. The logical form Heim assumed for a sentences with indefinites in FCS.

#+begin_export latex
\begin{forest}
  [{\(T\)\\\(;\)}
  [{\(T\)\\\(;\)}
    [{\(T\)\\a\(^{x}\)}]
    [{\(T\)\\\(t_x\) man}]
  ]
    [{\(T\)\\\(t_x\) walked in}]
  ]
\end{forest}
#+end_export

How to derive this syntactically? One possibility: 

- A determiner indexed \(x\) moves to the edge of the DP, leaving behind a trace \(t_x\).
- The DP inherits its index from the D head.
- The DP moves to the edge of the sentence, leaving behind a trace \(t_x\). 

A design feature of FCS is that sentences with indefinites are essentially equivalent to introducing a novel variable, and sequentially adding information to it.

#+name: ex:indefinite1
#+begin_exe
\ex A\(^x\) man walked in.
\ex There is someone\(^x\). He\(_x\) is a man. He\(_x\) walked in.
#+end_exe

This property is responsible for the validity of /Egli's theorem/ in FCS. Egli's theorem states that sentences of the following kind are equivalent.

\[\text{A}^x\text{ man [walked in and sat down]} \iff \text{A}^x\text{ man walked in and he}_x\text{ sat down}\]

** Compositionality

There are many reasons to be dissatisfied with FCS as a theory of subsentential compositionality. 

Every natural language constituent is treated as either (i) a CCP, or (ii) an operator on CCPs. This is a somewhat inflexible mold.

- To what extent is it compatible with concurrent developments in formal semantics, in the Montagovian tradition?
- What do predicates mean in FCS?
- Does dynamic semantics really commit us to specific syntactic transformations? Why?  
  
 We'll talk more about dynamic approaches to subsentential compositionality next week.

** Donkey anaphora and universal quantification

*** Interpreting universal statements

#+name: ex:cat
#+begin_exe
\ex Every cat died.
#+end_exe

In FCS, universal quantifiers are higher-order operators on CCPs, just like other logical vocabulary.

Unlike conjunction however, a quantificational determiner does not trigger simple successive updates, but does something more complex. 

One way of cashing out the meaning of quantificational deteminers in FCS is to assume a logical form like the one given in ([[ex:catlf]]), where the indefinite is silent.

#+name: ex:catlf
#+begin_exe
\ex every [a\(^x\) cat] [\(t_x\) died]
#+end_exe

We'll need an auxiliary equivalence relation on assignments - we'll say that assignments are /file-equivalent/ iff they agree on all familiar variables.[fn:8][fn:11]

#+begin_definition
file-equivalence for assignments. Given a file context \(c\), file-equivalence for two assignments \(g,g'\) is defined as follows.

\[g \sim_c g' \iff  \forall v[\mathbf{fam}_c(v) \rightarrow (g_v = g'_v)]\]
#+end_definition

We'll use this to ensure that the quantifier ranges over all possible values for *novel* variables. 

Now, the meaning of /every/ (definition taken from [cite:@Heim2017]).

#+name: def:universal-fcs
#+begin_exe
\ex \(\mathbf{every}(p)(q) := \lambda c\,.\,\Set{(w,g)\in c|\begin{aligned}[c]
&\forall g'[g' \sim_c g \wedge (w,g') \in p(c)\\
&\rightarrow \exists g''[g'' \sim_{p(c)} g' \wedge (w,g'') \in q(p(c))]]
\end{aligned}}\)
#+end_exe

What's happening here? Let's go through it step-by-step.

- Tentatively update \(c\) with with the restrictor; return \(p(c)\).
- Tentatively update \(p(c)\) with the nuclear scope; return \(q(p(c))\).
- Now, for each \((w,g) \in c\), run the following test: 
  * Take every \(c\)-equivalent \(g'\), such that \((w,g')\) in \(p(c)\).
  * See if you can find a \(p(c)\)-equivalent \(g''\) in \(p(q(c))\).
- Only keep those world assignment pairs \((w,g) \in  F\) that pass the test.
  
*** A concrete example
  
In order to understand how this works, it's worth going through a concrete example.

#+name: ex:catsdied
#+begin_exe
\ex every [a\(^x\) cat] [\(t_x\) died]
#+end_exe

Consider the following logical space \(W\), with domain \(a,b\):

- \(w_\emptyset \): \(a,b\) are cats; neither died.
- \(w_a\): \(a\) is a cat and \(b\) is a dog; both died.
- \(w_b\): \(a,b\) are cats; only \(b\) died.
- \(w_{ab}\): \(a,b\) are cats, both died.

Updating \(c_\top\) with "every cat died" should eliminate world-assignment pairs involving \(w_\emptyset, w_b\).
  
Given a stock of variables \(x,y\), the initial state is given by taking the product of \(W\) and the set of possible assignments:

\[\Set{\left[\begin{aligned}[c]
x \to a\\
y \to a
\end{aligned}\right],\left[\begin{aligned}[c]
x \to a\\
y \to b
\end{aligned}\right],\left[\begin{aligned}[c]
x \to b\\
y \to a
\end{aligned}\right],\left[\begin{aligned}[c]
x \to b\\
y \to b
\end{aligned}\right]}\] 

#+name: every-step1
#+begin_exe
\ex \(\begin{aligned}[t]
&c_\top[\text{every cat died}]\\
&= \Set{(w,g)\in c_\top |\begin{aligned}[c]
&\forall g'[g' \sim_{c_\top} g \wedge (w,g') \in p(c_\top)\\
&\rightarrow \exists g''[g'' \sim_{p(c_\top)} g' \wedge (w,g'') \in q(p(c_\top))]]
\end{aligned}}
\end{aligned}
\)
#+end_exe

Every variable is novel in \(c_\top\) so this can be simplified as follows:

#+name: every-step2
#+begin_exe
\ex \(\begin{aligned}[t]
&c_\top[\text{every cat died}]\\
&= \Set{(w,g)\in c_\top |\begin{aligned}[c]
&\forall g'[(w,g') \in p(c_\top)\\
&\rightarrow \exists g''[g'' \sim_{p(c_\top)} g' \wedge (w,g'') \in q(p(c_\top))]]
\end{aligned}}
\end{aligned}
\)
#+end_exe

\[\begin{aligned}[t]
&c_\top[\text{every cat died}]\\
&= \Set{(w,g)\in c_\top|\begin{aligned}[c]
&\forall g'[(w,g') \in c_\top \wedge \mathbf{cat}_w(g'_x)\\
&\rightarrow \exists g''[g'' \sim_x g' \wedge (w,g'') \in c_\top \wedge \mathbf{catThatDied}_w(g''_x)]]
\end{aligned}}
\end{aligned}
\]

What this says is that \((w,*)\) is retained in the output file context iff, every assignment \(g'\) paired with \(w\) that maps \(x\) to a cat is s.t. we can find an assignment \(g''\) that maps \(x\) to the same value, and \(g''\) maps \(x\) to a cat that died in \(w\).
 
This will clearly succeed for \((w_a,*),(w_{ab},*)\), and fail for \((w_\emptyset,*),(w_b,*)\)
  
*** Extension to donkey anaphora

One of the original motivations for FCS was giving a semantic account of pronouns in sentences such as the following.

#+name: ex:donkey
#+begin_exe
\ex Every philosopher who had a\(^y\) question asked it\(_y\).
#+end_exe

The extension to donkey anaphora is straightforward - the schema for universal quantification ensures that the quantifier ranges over all possible values for all novel variables in the input context.

Logical form for ([[ex:donkey]]):

- Every [ a\(^x\) philosopher a\(^y\) question \(t_x\) with \(t_y\)] [\(t_x\) asked it\(_y\)]

The FCS approach to donkey anaphora has some well known problems, which we'll return to in future classes, namely:

- Weak readings [cite:@Chierchia1995;@Kanazawa1994].
- The proportion problem
  
#+name: credit2
#+begin_exe
\ex Everyone who had a credit card used it.
\ex Most men who own a donkey beat it.
#+end_exe

Predicted reading: most man-donkey-he-owns pairs \((m,d)\) are s.t. \(m\) beats \(d\).

Falsifying scenario: /99 men own one donkey and don't beat it; one man owns 200 and beats them all./

** Other logical operators in FCS

Heim only gives a cursory treatment of other logical operators in her dissertation, so we won't include a detailed discussion here.

Thanks to the expressive power afforded to operations which manipulate CCPs, there are many possibilities. Here is what Heim suggests for negation:

- Tentatively update \(c\) with \(p\).
- Substract the file context \(c(p)\) from \(c\).

#+begin_definition
Negation in FCS.

\[\lambda p_T\,.\,\lambda c\,.\,c - p(c)\]
#+end_definition

#+name: neg
#+begin_exe
\ex Jocelyn didn't see a\(^x\) rock climber; ?They\(_x\) sent the route.
#+end_exe

Whether or not an indefinite c-commanded by a negative operator may antecede a pronoun is a fact concerning its relative scope. 

N.b. there was a good reason Heim proposed this entry for negation - she wanted to capture the fact that negation is a "hole" (in Karttunen's sense [cite:@Karttunen1973]) for the purposes of presupposition projection. That is to say that "Jocelyn didn't see the\(_x\) rock climber" presupposes a familiar rock climber \(x\).

#+name: neg2
#+begin_exe
\ex Jocelyn didn't see any\(^x\) rock climber. ?They\(_x\) sent the route.<<neg2:narrow>>
\ex Jocelyn didn't see some\(^x\) rock climber. They\(_x\) sent the route.
#+end_exe

Subsequent dynamic theories aim to account for this datapoint by making negation /externally static/, as we'll see when we discuss DPL. 

Surprisingly, Heim's entry for negation predicts anaphora to be possible in ([[neg]]) and /both/ of the examples in ([[neg2]]).

Why? FCS file contexts contain assignments specified for /every/ variable, even if nothing is known about some variables.

In ([[neg]]), the first sentence is an instruction to update the initial context \(c\) with the information that \(x\) is a rock climber seen by Jocelyn, so that we end up just with a \(c'\) where \((w,g) \in c'\) are s.t. \(g_x\) is a rock climber seen by Jocelyn in \(w\). Now we /subtract/ \(c'\) from \(c\), *eliminating* \((w,g)\)'s where \(g_x\) is a rock climber seen by Jocelyn in \(w\), resulting in \(c''\). 

This, of course, renders \(x\) /familiar/ in \(c''\), since worlds in \(c''\) distinguish between assignments which differ only at \(x\), predicting that subsequent anaphora should be possible.

We'll address this (apparently bad) prediction when we discuss DPL negation.

** Open questions 

We've gone through the basics of FCS, arguably the first real dynamic semantic proposal.

Some questions to keep in mind:

- What makes FCS /dynamic/, as opposed to a more classic semantics that treats sentence meanings as functions from evaluation points to truth-values?
- Is the additional expressive power afforded by CCPs in the semantics warranted?
- Is /novelty/ as a file-level notion unavoidable?
- How does logical vocabulary such as negation and disjunction interact with anaphora? Does FCS have a satisfying story (hint: it does not).
- Does dynamic semantics inescapably wed us to a non-standard view of subsentential composition?

* DPL  

#+begin_quote
"The general starting point of the kind of semantics that DPL is
an instance of, is that the meaning of a sentence does not lie in
its truth conditions, but rather in the way it changes (the repre-
sentation of) the information of the interpreter. The utterance
of a sentence brings us from a certain state of information to
another one. The meaning of a sentence lies in the way it brings
about such a transition." [cite:@GroenendijkStokhof1991]
#+end_quote

** Random assignment

Dynamic Predicate Logic (DPL) provides a dynamic interpretation schema for a simple first-order calculus.

[cite:@GroenendijkStokhof1991] give a relational presentation of DPL - formulas are interpreted relative to an evaluation point (a pair of assignments) and return a boolean value.

Here, I give an isomorphic presentation which emphasizes two key features of the DPL interpretation schema: (i) statefulness, and (ii) non-determinism.

Formulas are interpreted relative to an evaluation point (an assignment) and return a /set of evaluation points/.

#+begin_definition
DPL semantics for atomic formulas. For any model \(M := (D,I)\)

\[\eval*[g][M]{t} = \begin{cases}
g_t&t \text{ is a variable}\\
I(t)&t \text{ is a constant} 
\end{cases}\]

\[\eval[g][M]{P(t_1,\ldots,t_n)} = \begin{cases}
\set{g}& \braket{\eval*[g][M]{t_1},\ldots,\eval*[g][M]{t_n}} \in I(P)\\
\emptyset&\text{otherwise} 
\end{cases}\]
#+end_definition

An example:

#+name: ex:dpl1
#+begin_exe
\ex \(\eval*[g]{\mathtt{Swim}(x)} = \begin{cases}
\set{g}&g_x\text{ swims}\\
\emptyset&\text{otherwise}  
\end{cases}\)
#+end_exe

Atomic formulas in general are *tests*, i.e., identity relations on assignments.

Existential quantifiers induce what is known as *random assignment* in the dynamic literature.

#+begin_definition
DPL semantics for existential quantification.

\[\eval*[g]{\exists x,\phi} = \bigcup\limits_{a \in D}\set{g^{[x \to a]} | \eval*[g^{[x \to a]}]{\phi }}\]
#+end_definition

An example, where \(D = \set{a,b,c}\):

#+name: ex:dpl2
#+begin_exe
\ex \(\eval*[g]{\exists x[\mathtt{Swim}(x)]} = \set{g^{[x \to a]} | a\text{ swims} } \cup \set{g^{[x \to b]} | b\text{ swims} } \cup \set{g^{[x \to c]} | c\text{ swims} }\)
#+end_exe

Given a single evaluation point \(g\), existential quantification gives rise to a /potentially non-deterministic output/.

#+begin_definition
Truth in DPL. A formula \(\phi \) is /true/ with respect to an assignment \(g\) iff \(\eval*[g]{\phi } \neq \emptyset\)
#+end_definition

An important fact about existential quantification in DPL: it is /externally dynamic/.

*** Downdate

A curious property of DPL existential quantification is that it can destroy information established about a particular variable \(x\).

#+name: ex:downdate
#+begin_exe
\ex \(\exists x[\mathtt{walkedIn}(x)] \wedge \exists x[\mathtt{satDown}(x)]\)
#+end_exe

Since DPL is a semantics for predicate logic, not natural language, it's unclear whether this is really a problem.

Nevertheless, we'll attempt to get rid of this issue when we refactor FCS using ideas from DPL by incorporating a version of Heim's novelty condition.

** Complex formulas

*** Conjunction in DPL

Conjunction in DPL is intepreted as /relational composition/.

#+begin_definition
Conjunctive formula in DPL.

\[\eval*[g]{\phi \wedge \psi} = \bigcup\limits_{h \in \eval*[g]{\phi}}\set{ i | i \in \eval*[h]{\psi}}\]
#+end_definition

This allows the indeterminate output induced by an existential quantifier to be picked up by a matching variable outside of its ordinary scope. Let's again assume that our domain consists of three individuals \(\set{a,b,c}\).

#+name: dpl-conj-ex
#+begin_exe
\ex \(\eval*[g]{\exists x[\mathtt{WalkedIn}(x)] \wedge \mathtt{satDown}(x)}\)
\ex \(= \bigcup\limits_{h \in \eval*[g]{\exists x[\mathtt{walkedIn}(x)]}}\set{i | i \in \eval*[h]{\mathtt{satDown}(x)}}\) 
\ex \(=\bigcup\limits_{h \in \set{g^{[x \to a]}|a\text{ walked in}}}\set{i | i = h \wedge h_x\text{ sat down} } \)
\ex \(= \set{g^{[x \to a]}| a\text{ walked in and }a\text{ sat down}}\)
#+end_exe

An important fact about conjunction in DPL: it is both /internally/ and /externally/ dynamic.

Egli's theorem:

#+name: egli
#+begin_exe
\ex \(\exists x,\phi \wedge \psi \iff  \exists x[\phi \wedge \psi]\)
#+end_exe

*** Negation in DPL

Negation in DPL is tests whether the embedded formula is classically false.

#+begin_definition
Negated formula in DPL.

\[\eval*[g]{\neg\ \phi} = \begin{cases}
\set{g}&\eval*[g]{\phi} = \emptyset\\
\emptyset &\text{otherwise} 
\end{cases}\]
#+end_definition

Some important facts about negation in DPL:

- Negation is /externally static/.
- Double-negation elimination isn't valid.
  
Exercise: work through how DPL negation accounts for the facts discussed concerning the interaction between negation and anaphora.

#+name: joc
#+begin_exe
\ex \(\neg \exists x[\mathtt{seenByJocelyn}(x)] \wedge \mathtt{sentTheRoute}(x)\)
#+end_exe

\[
\eval*[g]{\neg\exists x[\mathtt{seenByJocelyn}(x)]} = \begin{cases}
\set{g}&\set{g^{[x \to c]}|c\text{ was seen by Jocelyn}} \neq \emptyset\\
\emptyset & \text{otherwise} 
\end{cases}
\]
  
But, as G&S themselves notice, the prediction for double negation doesn't seem right (see also [cite:@KrahmerMuskens1995]; example from [cite:@Gotham2019])

#+name: gotham1
#+begin_exe
\ex John doesn't own no^x shirt. It_x's in his closet.
#+end_exe

We'll come back to the status of negation in dynamic semantics in two weeks time, when we discuss externally-dynamic dynamic semantics (but see [cite:@KrahmerMuskens1995;@Gotham2019;@Hofmann2019]).

*** Material implication in DPL

For conditional formula, we check that the outputs of the antecedent are a subset of the assignments that make the consequent classically true.

#+begin_definition
Conditional formula in DPL.

\[\eval*[g]{\phi \rightarrow \psi} = \begin{cases}
\set{g}&\eval*[g]{\phi} \subseteq \set{h | \eval*[h]{\psi} \neq \emptyset}\\
\emptyset &\text{otherwise} 
\end{cases}\]
#+end_definition

An important fact about implication in DPL:

- Implication is externally static, but internally dynamic.
  
Material implication in DPL assigns existential quantifiers in the antecedent universal force. This underlies the DPL account of donkey anaphora.

Egli's corrolary: \((\exists x,\phi ) \rightarrow \psi \iff \forall x[\phi \rightarrow \psi]\)

#+name: donkey-dpl1
#+begin_exe
\ex If a\(^x\) donkey brays, it\(_x\) is unhappy.
\ex Every donkey that brays is unhappy.
#+end_exe

#+name: donkey-dpl2
#+begin_exe
\ex \((\exists x[\mathtt{BrayingDonkey}(x)]) \rightarrow \mathtt{Unhappy}(x)\)
#+end_exe

We know that the meaning of ([[donkey-dpl2]]) is a test on \(g\).

#+name: donkey-dpl3
#+begin_exe
\ex \(\eval*[g]{\exists x[\mathtt{BrayingDonkey}(x)]} = \set{g^{[x \to a]}|a\text{ is a braying donkey} }\)
\ex \(\eval*[h]{\mathtt{Unhappy}(x)} = \begin{cases}
\set{h}&h_x\text{ is unhappy}\\
\emptyset &\text{otherwise}  
\end{cases}\)
#+end_exe

- Scenario 1: no donkeys brayed. The antecedent has an empty output and the sentence is trivially true.
- Scenario 2: Donkey \(d_1\) brayed and is unhappy, donkey \(d_2\) brayed and is happy.
  + The output of the antecedent contains assignments that map \(x\) to \(d_1\), and assignments that map \(x\) to \(d_2\).
  + The assignments that make the consequent classically true are just those that map \(x\) to \(d_1\).
  + The test fails.
- Scenario 3: Donkeys \(d_1\) brayed and is unhappy, donkey \(d_2\) didn't bray but is nevertheless unhappy.
  + The output of the antecedent contains assignments that map \(x\) to \(d_1\).
  + The assignments that make the consequent classically true are just those that map \(x\) to \(d_1\) or \(x\) to \(d_2\). 
  + The test passes.
    
An important fact about material implication in DPL: \(\phi \rightarrow \psi \iff \neg (\phi \wedge \neg\ \psi)\) (a classical equivalence).

N.b. connectives can be defined under classical equivalence in DPL, but which classical equivalence matters! This is one way of understanding the explanatory challenge to dynamic semantics.

For example, we'd get a very different (bad) result if we defined material implication in DPL as \(\neg \phi \vee \psi\).

On the external staticity of material implication in DPL (examples from [cite:@Gillies2019]):

#+name: ext
#+begin_exe
\ex If a farmer owns a^x donkey, he feeds it_x hay. It_x is happy with that meal.
\ex If a farmer is happy, he feeds a^x donkey hay. ??It_x is happy with that meal.
#+end_exe

*** Disjunction in DPL

#+begin_definition
Disjunctive formula in DPL.

\[\eval*[g]{\phi \vee \psi} = \begin{cases}
\set{g}&\eval*[g]{\phi } \cup \eval*[g]{\psi} \neq \emptyset\\
\emptyset&\text{otherwise} 
\end{cases}\]
#+end_definition

An important fact about disjunction in DPL:

- Disjunction is both /externally and internally static/.
  
#+name: disj1
#+begin_exe
\ex ??Either a\(^x\) farmer left, or he\(_x\) whistled.
\ex ??It's not the case [that a\(^x\) farmer left or that he\(_x\) whistled].
#+end_exe

#+name: disj2
#+begin_exe
\ex Either a\(^x\) philosopher is here, or the party is dull; ??They\(_x\) are causing a scene.
#+end_exe

Some well known problems for DPL disjunction: /bathroom disjunctions/ (due to Barbara Partee).

#+name: bathroom1
#+begin_exe
\ex Either there isn't a\(^x\) bathroom, or it\(_x\)'s upstairs. 
#+end_exe

Another problem for DPL disjunction was noted by G&S themselves. We might call them G&S disjunctions.

#+name: gs-disj
#+begin_exe
\ex Either a\(^x\) philosopher was in the audience, or a\(^x\) linguist was; (Either way) they\(_x\) enjoyed it.
#+end_exe

Although the resolution for bathroom disjunctions is unclear, it's worth emphasizing that DPL at least has the resources to give an entry for G&S disjunctions, but it involves positing an ambiguity.

#+begin_definition
Program disjunction in DPL.

\[\eval*[g]{\phi \cup \psi} = \eval*[g]{\phi } \cup \eval*[g]{\psi}\]
#+end_definition

*** Universal quantification

#+begin_definition
Universally quantified formula in DPL.

\[\eval*[g]{\forall x,\phi } = \begin{cases}
\set{g}&\set{g^{[x \to a]}| a \in D} \subseteq \set{h | \eval*[h]{\phi} \neq \emptyset }\\
\emptyset &\text{otherwise} 
\end{cases}\]
#+end_definition

A fact about universal quantification in DPL: \(\forall x,\phi \iff  \neg\exists \neg\phi \)

** The relationship between DPL and FCS

Recall, if we switch to a partial setting, we can check novelty/familiarity at individual evaluation points.

#+begin_definition
Novelty and familiarity with respect to an assignment \(g\).

\[\mathbf{nov}_g(x) \iff x \notin \mathbf{dom}(g)\]

\[\mathbf{fam}_g(x) \iff  x \in \mathbf{dom}(g)\]
#+end_definition

We speculated that this might allow us to make FCS distributive, but we ran into a stumbling block when considering the meanings of logical operators.

We can extend the DPL notion of a sentential meaning to a setting that incorporates worldly information as follows:

#+name: hybrid1
#+begin_exe
\ex \(\eval[w,g]{it's raining} = \begin{cases}
\set{g}&\mathbf{satDown}_w(g_x)\\
\emptyset&\text{otherwise} 
\end{cases}\)
#+end_exe

Information states in partial pointwise FCS:

#+begin_definition
Information states in partial pointwise FCS. An information state is a set of pairs \((w,g)\), where \(w\) is a possible world, and \(g\) is a partial assignment. The initial information state is \(W \times g_\emptyset  \).
#+end_definition

#+begin_definition
Bridge principle in partial pointwise FCS.

\[c[\phi] = \begin{cases}
\bigcup\limits_{(w,g) \in c}\set{(w,g')| g' \in \eval*[w,g]{\phi}}&\forall(w,g) \in c[\phi \in \mathbf{dom}(\eval*[w,g]{.})]\\
\text{undefined}&\text{otherwise}  
\end{cases}\]
#+end_definition

We keep the DPL semantics for existentials (already implicit in our presentation of partial DPL), but incorporate a novelty check in order to avoid the downdate problem (see also [cite:@Dekker1996]).

#+name: hybrid2
#+begin_exe
\ex \(\eval*[w,g]{\text{someone}^x\text{ walked in}} = \begin{cases}
\bigcup\limits_{a \in D}\set{g^{[x \to a]}|\mathbf{walkedIn}_w(a) } & \mathbf{nov}_g(x)\\
\text{undefined}&\text{otherwise}  
\end{cases}\)
#+end_exe

Sentences with definites are tests:

#+name: hybrid3
#+begin_exe
\ex \(\eval*[w,g]{\text{she}_x\text{ sat down}} = \begin{cases}
\set{g}&\mathbf{fam}_g(x) \wedge \mathbf{satDown}_w(g_x)\\
\emptyset &\mathbf{fam}_g(x) \wedge  \neg\ \mathbf{satDown}_w(g_x)\\
\text{undefined}&\text{otherwise}  
\end{cases}\)
#+end_exe

The semantics for logical operators are retained from DPL, e.g.,

#+name: conj-partial
#+begin_exe
\ex \(\eval*[w,g]{\phi\text{ and }\psi} = \bigcup\limits_{h \in \eval*[w,g]{\phi}}\set{ i | i \in \eval*[w,h]{\psi}}\)
#+end_exe

The contribution of /and/ is classical with respect to worldly information.

Intuitively, switching to partial pointwise DPL takes a classical setting, and replaces falsity with an empty output set, and gives many different ways of being true.

Note that the way that novelty/familiarity interact with the logical operators looks suspiciously like presupposition projection. This is something the current system doesn't capture (in fact, we haven't yet incorporated a sensible theory of presupposition).

* Conclusion

By taking inspiration from DPL, we've managed to eliminate some of the more egregious features of FCS while retaining its core advantages.

* References

\printbibliography

* File local variables                                             :noexport:

* Footnotes

[fn:12] I'm grateful to Yasu Sudo for raising this issue. 
[fn:11] Note that, in a partial setting, two assignments are file-equivalent simply if they are extensionally equivalent functions (since novel variables aren't in the domain). 

[fn:10] In her dissertation, Heim addresses this issue by giving files an additional domain parameter [cite:@Heim1982].  
[fn:9] See [cite:@Chierchia1995] for a detailed comparison. 

[fn:8] The presentation here is based on discussion in [cite:@Heim2017]. 
[fn:7] [cite:@Chierchia1995] goes as far as to suggest that a semantics is /dynamic/ iff the meaning of conjunction is function composition. We'll see many reasons to reject this characterization in the following classes.

[fn:6] Another possible resolution, which to my knowledge hasn't been explored in any depth, is to adopt a non-Lewisian logical foundation in which certain tautologies can be distinguished, such as truthmaker/situation semantics [cite:@Fine2017;@Fine2017a;@Fine2017b].

[fn:5] This is essentially the /random assignment/ of dynamic predicate logic [cite:@GroenendijkStokhof1991]. We'll expand on this next week. 
[fn:4] In more traditional mathematical notation, we'd write this as \(\psi \circ \phi\). I prefer \(\phi ; \psi\), as it more directly reflects information flow in a dynamic setting. 

[fn:3] Here we use Beaver's \(\delta\) operator [cite:@Beaver2001], which maps \(\mathbf{1}\) to \(\mathbf{1}\), and \(\mathbf{0}\) to \(\mathbf{\#}\). We additionally assume that \(\wedge\) denotes /weak Kleene/ conjunction. 

[fn:2] We use \(*\) as a wildcard over values (i.e., an implicitly existentially-quantified variable). 

[fn:1] \(g[x \to  a]\) is the unique assignment that is identical to \(g\), except for mapping \(x\) to \(a\).

# Local Variables:
# mode: org
# org-latex-default-packages-alist: nil
# org-latex-with-hyperref: nil
# End:
