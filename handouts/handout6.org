#+title: Possible witnesses
#+author: Patrick D. Elliott 
#+bibliography: ../../bibliography/master.bib
#+setupfile: handout-template.org
#+OPTIONS: ':t
#+cite_export: biblatex

* Next week

- *Today:* more on modality and anaphora.
- *Next week:* no class (Patriot's day).
- *April 25:* introduction to dynamic plural logic [cite:@vandenBerg1996;@Nouwen2003].
- *May 2:* Filipe on postsuppositions.
- *May 9:* TBC.
  
* Background reading for today's class

- [cite:@Veltman1996]
- [cite:@GroenendijkEtAl1996]
- [cite:@Hofmann2019]
- [cite:@Willer2013]
- [cite:@Goldstein2019]
  
* Questions for today

How far can we get with the following generalization (which naturally emerges from EDS; see also [cite:@Mandelkern2022]).

#+begin_importantblock
*Witness generalization:* an assertion of a sentence \(\phi \) containing an existential statement indexed \(v\) introduces a dref \(v\) if the assertion is accepted and contextually entails the existence of a witness to the existential statement.
#+end_importantblock

Thanks to the interplay of positive/negative anaphoric information, and Strong Kleene semantics in EDS, introduction of a discourse referent tracks classical (contextual) entailment of a witness.

The existence of expressions which (arguably) explore contextual possibilities - /epistemic modals/ - disrupts the witness generalization. 

Some problematic data - most prominently, the /possible bathroom/.

#+name: poss-bath
#+begin_exe
\ex There might be a\(^v\) bathroom. It\(_v\) might be upstairs.<<poss-bath1>>
#+end_exe

The problem here is clear. ([[poss-bath1]]) is a coherent discourse, whereas ([[poss-bath2]]) is not.

Note that a subsequent pronoun is licensed (and therefore, a discourse referent introduced?) even though "There might be a\(^v\) bathroom" doesn't contextually entail a witness to the existential statement. After all, a claim about the /possibility/ of there being a bathroom doesn't commit one to the actual existence of a bathroom.

Intriguingly, the possibility of a subsequent pronoun is /conditioned by the environment in which the pronoun occurs/.

#+name: poss-bath2
#+begin_exe
\ex There might be a\(^v\) bathroom. ??It\(_v\)'s upstairs.
#+end_exe

If the pronoun doesn't occur in a modalized environment, the discourse is incoherent - intuitively, this is because the familiarity presupposition of the pronoun isn't satisfied, since a witness isn't contextually entailed.

So, what's going on in ([[poss-bath]])? A related, and more difficult case:

#+name: poss-bath3
#+begin_exe
\ex Maybe there's no\(^v\) bathroom, and maybe it\(_v\)'s upstairs.
#+end_exe

We'll explore the idea that modalized sentences can make variables /partially familiar/ - something we've already seen when looking at the anaphoric potential of disjunctive sentences.

We'll formalize this using plain old Heimian file contexts, using an under-exploited aspect of their expressive power.

We'll furthermore argue that we can maintain the /witness generalization/, which emerges from the presuppositional requirements of pronouns. In order to account for the problematic data, we'll need to refine our undertanding of presupposition projection in modalized sentences.

Ultimately I'll argue for a departure from the received opinion regarding projection in modalized environments --- if \(\phi \) presupposes \(\pi \), then \(\Diamond \phi \) presupposes \(\Diamond \pi \).

To get there, we'll start with a simple implementation of epistemic modality in update semantics [cite:@Veltman1996;@GroenendijkEtAl1996], and from there lift EDS into an update semantics in order to incorporate modality into our account of anaphora.

* Veltman's test

The /locus classicus/ for epistemic modality in dynamic semantics is Veltman's test semantics [cite:@Veltman1996;@GroenendijkEtAl1996].

Veltman's idea: a sentence \(\Diamond\phi \) is an instruction to hypothetically update an information state \(c\) with \(\phi \), returning \(c\) unchanged if \(c\) can be consistently updated with \(\phi\), and the absurd state otherwise. 

#+name: might1
#+begin_exe
\ex \(c[\text{it might be raining}]\)
\begin{xlist}
\ex Compute \(c[\text{it's raining}]\); store the result as \(c'\).
\ex Is \(c'\) are non-absurd information state? If so, return \(c\).
\ex Otherwise, return \(c'\).
\end{xlist}
#+end_exe

** Formalizing Veltman's /might/

An update semantics for a simple propositional fragment (directly encoding a notion of local context) [cite:@Veltman1996].

#+name: update
#+begin_exe
\ex \(c[p] := c \cap I(p)\)
\ex \(c[\neg\,\phi] := c - c[\phi]\)
\ex \(c[\phi \wedge \psi] := c[\phi][\psi]\)
\ex \(\phi \vee \psi := \neg\,(\neg\,\phi \wedge \neg\,\psi)\)
\ex \(\phi \to \psi := \neg\,(\phi \wedge \neg\,\psi)\)
\end{xlist}
#+end_exe

#+begin_definition
*Test semantics for /might/.*

\[c[\Diamond \phi] := \begin{cases}
c & c[\phi] \neq \emptyset\\
\emptyset & \text{otherwise} 
\end{cases}\]
#+end_definition

In Veltman's update semantics, \(\emptyset \) is the /absurd state/, i.e., the information state from which everything follows. "It might be raining":

#+name: might-rain
#+begin_exe
\ex \(c[\Diamond r] = \begin{cases}
c& c \cap I(r) \neq \emptyset\\
\emptyset &\text{otherwise} 
\end{cases}\)
#+end_exe

Veltman's /might/ expores possibilities in \(c\), and returns \(c\) unchanged just in case there is at least one /raining/ possibility.

** Epistemic /must/ as the dual of /might/

If we define update-semantic negation, we can treat /must/ as the dual of /might/.

#+begin_definition
*Test semantics for /must/.*

\[c[\Box \phi] := c[\neg\,\Diamond\,\neg\,\phi]\]

\[c[\Box \phi] := \begin{cases}
c&c[\phi] = c\\
\emptyset&\text{otherwise} 
\end{cases}\]
#+end_definition

In Veltman's terms, /must \(\phi \)/ is true in a context \(c\) if \(\phi \) is /accepted/ in \(c \). "It must be raining":

#+name: must-rain
#+begin_exe
\ex \(c[\Box r] = \begin{cases}
c&c \cap I(r) = c&
\emptyset &\text{otherwise} 
\end{cases}\)
#+end_exe

/Must/ explores possibilities in \(c\), and returns \(c\) unchanged just in case every possibility is a /raining/ possibility.

** Sensitivity to local context

To see how Veltman's /might/ derives sensitivity to local context (as discussed last time), we'll go through a simple example involving a conditional statement.

#+name: if-then
#+begin_exe
\ex If it's raining then it must be wet.\\
\(r \to \Box\,w \iff \neg\,(r \wedge \neg\,\Box\,w)\)
#+end_exe

#+name: if-then-comp
#+begin_exe
\ex
\begin{xlist}
\ex \(c[\neg\,(r \wedge \neg\,\Box w)]\)
\ex \(= c - c[r \wedge \neg\,\Box w]\)
\ex \(= c - c[r][\neg\,\Box w]\)
\ex \(= c - ((c \cap I(r)) - ((c \cap I(r))[\Box\,w])\)
\end{xlist}
#+end_exe

** Epistemic contradictions

A signature feature of Veltman's test semantics - it derives epistemic contradictions [cite:@Yalcin2007].

#+name: raining
#+begin_exe
\ex ??Suppose that it's raining, and it might not be raining.
#+end_exe

It's easy to see that for any information state \(c\), \(c[\phi][\Diamond\,\neg\,\phi]\) is guaranteed to return the absurd state.

We'll consider more complex examples involving anaphora in a moment.

* Modality and anaphora

Veltman's test semantics involves exploring properties of an information state; a modalized statement can't be judged true relative to an individual evaluation point.

In other words, incorporating epistemic modals into a simple update semantics renders the resulting system /non-distributive/ [cite:@RothschildYalcin2016].

In order to keep the theory of anaphora lean and restrictive, EDS is /distributive/ (but non-eliminative, just like DPL; [cite:@GroenendijkStokhof1991]).

** A terse presentation of EDS

#+name: def:eds-atom
#+begin_exe
\ex Atomic sentences: 
\begin{xlist}
\ex \(\eval*[w][+]{P(v_1,\ldots,v_n)} := \set{(g,h)|g = h \wedge |P(v_1,\ldots,v_n)|^{w,h}\text{ is \textbf{true}}}\)
\ex \(\eval*[w][-]{P(v_1,\ldots,v_n)} := \set{(g,h)|g = h \wedge |P(v_1,\ldots,v_n)|^{w,h} \text{ is \textbf{false}} }\)
\ex \(\eval*[w][u]{P(v_1,\ldots,v_n)} := \set{(g,h)|g = h \wedge |P(v_1,\ldots,v_n)|^{w,h}\text{ is \textbf{undefined}} }\)
\end{xlist}
\ex Negative sentences:
\begin{xlist} 
\ex \(\eval*[w][+]{\neg \phi } := \eval*[w][-]{\phi }\)
\ex \(\eval*[w][-]{\neg \phi } := \eval*[w][+]{\phi }\)
\ex\(\eval*[w][u]{\neg \phi } := \eval*[w][u]{\phi }\)
\end{xlist}
\ex Conjunctive sentences:
\begin{xlist}
\ex \(\eval*[w][+]{\phi \wedge \psi} := \eval*[w][+]{\phi } \circ \eval*[w][+]{\psi}\)
\ex \(\eval*[w][-]{\phi \wedge \psi} := \begin{aligned}[t]
&\eval*[w][-]{\phi} \circ \eval*[w][+,-,u]{\psi}\\
&\cup \eval*[w][+,u]{\phi} \circ \eval*[w][-]{\psi}
\end{aligned}\)
\ex \(\eval*[w][u]{\phi \wedge \psi} := \begin{aligned}[t]
&\eval*[w][+]{\phi } \circ \eval*[w][u]{\psi}\\
&\cup \eval*[w][u]{\phi } \circ \eval*[w][+,u]{\psi}
\end{aligned}\)
\end{xlist}
\ex Random assignment:
\begin{xlist}
\ex \(\eval*[w][+]{\varepsilon_v} := \set{(g,h)|g[v]h}\)
\ex \(\eval*[w][-]{\varepsilon_v} := \emptyset\)
\ex \(\eval*[w][u]{\varepsilon_v} := \emptyset\)
\end{xlist}
\ex Positive closure:
\begin{xlist}
\ex \(\eval*[w][+]{\dag\phi } := \eval*[w][+]{\phi}\)
\ex \(\eval*[w][-]{\dag\phi } := \set{(g,h)|g = h \wedge |\phi|^{w,g}\text{ is \textbf{false}} }\)
\ex \(\eval*[w][u]{\dag\phi } := \eval*[w][u]{\phi}\)
\end{xlist}
#+end_exe

** From EDS to EUS

Instead of interpreting sentences as /relations between assignments/ (relative to an evaluation world), we'll interpret sentences as /updates on Heimian information states/.

We'll write updates using iconic infix notation \(c[.]\); in order to carry over the key design features of EDS, we'll distinguish between the /positive/, /negative/, and /unknown/ effects of sentences on information states, via \(c[.]^{+,-,?}\) (EUS is a multivalent update semantics).

EDS can be straightforwardly lifted into a /multivalent update semantics/ (EUS).

*** Atomic sentences in EUS

Atomic sentences induce a tripartition of information states: \(c[\phi]^+\) is the part of \(c\) at which \(\phi \) is true, \(c[\phi]^-\) is the part of \(c\) at which \(\phi \) is false, and \(c[\phi]^?\) is the part of \(c\) at which \(\phi \) is unknown.

#+name: lifting-algo
#+begin_exe
\ex \(c[P(v_1\,\ldots\,v_n)]^+ := \set{(w,g) \in c||P(v_1,\ldots,v_n)|^{w,g}\text{ is \textbf{true}}}\)
\ex \(c[P(v_1\,\ldots\,v_n)]^- := \set{(w,g) \in c||P(v_1,\ldots,v_n)|^{w,g}\text{ is \textbf{false}}}\)
\ex \(c[P(v_1\,\ldots\,v_n)]^? := \set{(w,g) \in c||P(v_1,\ldots,v_n)|^{w,g}\text{ is \textbf{undefined}}}\)
#+end_exe

to illustrate, consider the sentence \(U(v)\) in light of the following information state \(c_1\) (\(a,b\) are upstairs in \(w_u\); \(b\) is downstairs in \(w_d\)):

#+name: bath-info
#+begin_exe
\ex \(\set{(w_u,[v \to a]),(w_u,[v \to b]),(w_d,[v \to b]),(w_\emptyset,[])} := c_1\)
#+end_exe

\(U(v)\) is of course not assertable at \(c_1\), since \(v\) isn't familiar at \(c_1\) (thanks to \(w_\emptyset \)).

We can however explore the true/false/undefined parts of \(c_1\) individually using \(c\braket{.}^{+,-,?}\).

#+name: posses
#+begin_exe
\ex \(c\braket{U(v)}^+  = \set{(w_u,[v \to a]),(w_u,[v \to b])}\) 
\ex \(c\braket{U(v)}^-  = \set{(w_d,[v \to b])}\) 
\ex \(c\braket{U(v)}^?  = \set{(w_\emptyset ,[])}\) 
#+end_exe

\(c\braket{U(v)}^{+,-,?}\) induces a tripartition of \(c_1\), since \(U(v)\) is a test.

In order to capture conditions on assertability, we still need a bridge principle in EUS...

*** Bridge principle in EUS

Our bridge principle requires that the unknown part of the context is empty; \(c_\#\) is the error state for context update.

#+name: bridge
#+begin_exe
\ex \(c[\phi] := c[\phi]^+\text{ if }c[\phi]^? = \emptyset\text{ else }c_\#\)
#+end_exe

*** Negative sentences in EUS

Negation is defined exactly as in EDS; we just flip the true/false parts of the information state.

#+name: neg
#+begin_exe
\ex \(c[\neg\,\phi]^+ := c[\phi]^{-}\)
\ex \(c[\neg\,\phi]^{-} := c[\phi]^{+}\)
\ex \(c[\neg\,\phi]^{?} := c[\phi]^{?}\)
#+end_exe

*** Random assignment in EUS

Random assignment is a tautology, which means that it is always true throughtout the information state.

#+name: ex
#+begin_exe
\ex \(c[\varepsilon_v]^{+} := \set{(w,h)|g[v]h \wedge (w,g) \in c}\)
\ex \(c[\varepsilon_v]^{-} := \emptyset \)
\ex \(c[\varepsilon_v]^{?} := \emptyset \)
#+end_exe

It's important to note that \(c\braket{\phi }^{+,-,?}\) doesn't always partition \(c\), since it can multiply possibilities.

\(\varepsilon_v\) always induces a trivial partition of an updated information state.

*** Conjunction in EUS

Conjunction is defined just as in EDS, only instead of interpreting each cell in the Strong Kleene truth table as relational composition, we interpret each cell as a successive update.

#+name: ex
#+begin_exe
\ex \(c[\phi \wedge \psi]^{+} := c[\phi]^+[\psi]^+\)
\ex \(c[\phi \wedge \psi]^{-} := c[\phi]^{-}[\psi]^{+,-,?} \cup c[\phi]^{+,?}[\psi]^{-}\)
\ex \(c[\phi \wedge \psi]^{?} := c[\phi]^{?}[\psi]^{+,?} \cup c[\phi]^{+}[\psi]^{?}\)
#+end_exe

*** Illustration: existential quantification

Let's see how this works briefly:

#+name: computation
#+begin_exe
\ex \(c[\varepsilon_v \wedge P(v)]^{+}\)
\ex \(c[\varepsilon_v]^+[P(v)]^+\)
\ex \(\set{(w,h)|g[v]h \wedge (w,g) \in c}[P(v)]^+\)
\ex \(\set{(w,h)|g[v]h \wedge (w,g) \in c \wedge h_v \in I_w(P)}\)
#+end_exe

Note that \(c[\varepsilon_v \wedge P(v)]^?\) is clearly empty for any information state \(?\), since \(c[\varepsilon_v]^?\) is empty for any information state, and \(c[\varepsilon_v]^+[P(v)]^?\) is guaranteed to be empty, since \(v\) is defined throughout.

The sentence therefore doesn't impose any requirements on assertability.

We can compute the negative update of the sentence in much the same fashion:

#+name: comp-neg
#+begin_exe
\ex \(c[\varepsilon_v \wedge P(v)]^-\)
\ex \(c[\varepsilon_v]^+[P(v)]^-\)
\ex \(\set{(w,h)|g[v]h \wedge (w,g) \in c \wedge h_v \notin I_w(P)}\)
#+end_exe

Just as in EDS, we need to supplement random assignment with a closure operator, in order to prevent existential quantification from commuting with negation.

*** Closure in EUS

One way of formulating positive closure in EUS is as follows:

#+name: ex
#+begin_exe
\ex \(c[\dag\phi]^{+} := c[\phi]^{+}\)
\ex \(c[\dag\phi]^{-} := \set{(w,g) \in c|(w,*) \notin c[\phi]^{+} \wedge (w,*) \in c[\phi]^-}\)
\ex \(c[\dag\phi]^{?} := c[\phi]^?\)
#+end_exe

Applying closure to ([[comp-neg]]), we get:

#+name: closed
#+begin_exe
\ex \(c[\dag(\varepsilon_v \wedge P(v))]^+ = c[\varepsilon_v \wedge P(v)]^+\)
\ex \(c[\dag(\varepsilon_v \wedge P(v))]^- = \set{(w,g) \in c | I_w(P) = \emptyset }\)
#+end_exe

* Adding consistency tests to EUS

Adding consistency tests to EUS is not trivial. Let's start with a naive implementation of (the positive update) of Veltman's test:

#+name: epist
#+begin_exe
\ex \(c[\Diamond\phi]^+ = c\text{ if }c[\phi]^+ \neq \emptyset \text{ else }\emptyset\)
#+end_exe

This says that /might \(\phi \)/ is true at \(c\) if there's a non-empty part of \(c\) at which \(\phi \) is true.

N.b. that since we're operating in a multivalent setting, I still owe you the negative/unkown extension of \(\Diamond \phi \).

*** Epistemic contradictions with anaphora

Recall from the discussion of Veltman's /might/: epistemic contradictions.

#+name: raining
#+begin_exe
\ex ??It's raining and it might not be raining.
#+end_exe

Epistemic contradictions extend to claims involving anaphoric dependencies [cite:@GroenendijkEtAl1996].

#+name: ec1
#+begin_exe
\ex ??Suppose that someone\(^v\) is hiding in the closet and they\(_v\) might not be hiding in the closet.
\ex \(\exists_vH(v) \wedge \Diamond\,\neg\,H(v)\)
\ex ??Suppose that someone\(^v\) hiding in the closet might not be hiding in the closet.
\ex \(\exists_v(H(v) \wedge \Diamond\,\neg\,H(v))\)
#+end_exe

We only need the positive extension of /might/ to show that we derive the triviality of ([[ec1]]).

#+name: ec2
#+begin_exe
\ex
\begin{xlist}
\ex \(c[\exists_vH(v)]^+ = \set{(w,h)|(w,g) \in c \wedge g[v]h \wedge h_v \in I_w(H)}\)
\ex \(c[\Diamond\,\neg\,H(v)]^+ = c\text{ if }c[H(v)]^- \neq \emptyset\text{ else }\emptyset  \)
\ex \(\begin{aligned}[t]
&c[\exists_vH(v)]^+[\Diamond\,\neg\,H(v)]^+\\
&\begin{aligned}[t]
&= c\text{ if }\set{(w,h)|(w,g) \in  c \wedge  g[v]h \wedge h_v \in  I_w(H)}[H(v)]^- \neq \emptyset \text{ else }\emptyset\\
&= c\text{ if }\set{(w,h)|(w,g) \in  c \wedge  g[v]h \wedge  h_v \in I_w(H) \wedge h_v \notin I_w(H)} \neq \emptyset \text{ else }\emptyset   
\end{aligned}\end{aligned}\)
\ex \(c[\exists_vH(v)]^+[\Diamond\,\neg\,H(v)]^+ = \emptyset, \forall c\)
\end{xlist}
#+end_exe

*** Disjunctive epistemic contradictions

A virtue of EUS over, e.g., [cite:@GroenendijkEtAl1996] is that it also accounts for a disjunctive variant of epistemic contradictions.

#+name: disj
#+begin_exe
\ex ??Either there's no\(^v\) bathroom upstairs, or it\(_v\) might not be upstairs.\\
\(\neg\,\exists_vU(v) \vee \Diamond\,\neg\,U(v)\)
#+end_exe

As soon as we spell out the local context of the second disjunct ([[disj2]]) one verification strategy for disjunction is trivial:

#+name: hurford
#+begin_exe
\ex There's no bathroom upstairs.<<disj1>>
\ex There's a\(^v\) bathroom upstairs and it\(_v\)'s possible it's not upstairs.<<disj2>>
#+end_exe

First, we need to flesh out the EUS semantics for disjunction. This is just Strong Kleene disjunction where each cell in the SK truth table is interpreted as a successive update.

#+name: ex
#+begin_exe
\ex \(c[\phi \vee \psi]^{+} := c[\phi]^{+}[\psi]^{+,-,?} \cup c[\phi]^{-,?}[\psi]^{+}\)
\ex \(c[\phi \vee \psi]^{-} := c[\phi]^-[\psi]^-\)
\ex \(c[\phi \vee \psi]^{?} := c[\phi]^{?}[\psi]^{-,?} \cup c[\phi]^{-}[\psi]^{?}\)
#+end_exe

Now consider the semantics of the disjuncts:

#+name: disj-contr 
#+begin_exe
\ex \(c[\neg\,\exists_vU(v)]^+ = \set{(w,g) \in c | I_w(U) = \emptyset }\)
\ex \(c[\neg\,\exists_vU(v)]^- = \set{(w,h)| (w,g) \in c \wedge g[v]h \wedge h_v \in I_w(U) }\)
\ex \(c[\Diamond\,\neg\,U(v)]^+ = c\text{ if }c[U(v)]^- \neq \emptyset \text{ else }\emptyset \)
#+end_exe

The problem here is that one way of verifying the disjunction: namely, if the first disjunct is false, and the second is true, turns out to be an epistemic contradiction and therefore trivial for any information state.

#+name: disj-ver
#+begin_exe
\ex \(c[\neg\exists_vU(v)]^-[\Diamond\,\neg\,U(v)]^+ = \emptyset, \forall c\)
#+end_exe

There's therefore only one way of verifying the disjunction - namely, if the first disjunct is true.

The disjunction as a whole is therefore contextually equivalent to the first disjunct "there is no bathroom".

* Impossibility and necessity

So far, we've only established the positive extension of a modalized sentence:

#+name: epist
#+begin_exe
\ex \(c[\Diamond\phi]^+ = c\text{ if }c[\phi]^+ \neq \emptyset \text{ else }\emptyset\)
#+end_exe

What does it mean to assert "it's not possible that \(\phi \)". Intuitively, this should be a test on \(c\) which checks whether there are any \((w,g) \in c\) that satisfy \(\phi \). If there aren't any, return \(c\), else return \(\emptyset \).

#+name: epist
#+begin_exe 
\ex Negative extension for modalized sentences (first attempt):\\
\(c[\Diamond\phi]^- = c\text{ if }c[\phi]^+ = \emptyset\text{ else }\emptyset\)
#+end_exe

This won't be quite enough however, given the partiality inherent in EUS.

Just to illustrate, consider an initial context \(c_\top := W \times \set{g_\top }\).

- \(c_\top[P(v)]^+ = \emptyset \)
- \(c_\top[P(v)]^- = \emptyset \)
- \(c_\top[P(v)]^? = c_T \)
  
We want "it's not possible that \(\phi \)" to ensure that (i) there are no \((w,g) \in  c^+\), and (ii) \(\phi \) is false throughout \(c\) (i.e., \(c = c^-\)).

#+name: epist2
#+begin_exe
\ex Negative extension for modalized sentences (second attempt):\\
\(c[\Diamond\phi]^- = c\text{ if }c[\phi]^+ = \emptyset \wedge c[\phi]^- = c\text{ else }\emptyset  \)
#+end_exe

What about presupposition projection? We'll come back to this later (but perhaps it's already clear that we predict something weaker than what is traditionally assumed).

Now that we have the negative and positive extension of \(\Diamond \phi \), we should be able to define \(\Box \) as the dual of \(\Diamond \).

#+name: must
#+begin_exe
\ex \(\Box \phi := \neg\,\Diamond\,\neg\,\phi \)
#+end_exe

Let's figure out exactly what this predicts.

#+name: dual
#+begin_exe
\ex \(c[\Box\phi]^+ = c[\Diamond\,\neg\,\phi]^-\)
\ex \(= c\text{ if }c[\neg\,\phi]^+ = \emptyset \wedge  c[\neg \phi]^- = c \text{ else }\emptyset  \)
\ex \(= c\text{ if }c[\phi]^- = \emptyset \wedge  c[\phi]^+ = c \text{ else }\emptyset  \)
#+end_exe

I.e., "must \(\phi \)" makes sure that \(c\) is inconsistent with \(\neg\phi \) and \(\phi \) is true throughout \(c\).

It follows that (i) "must \(\phi \)" dynamically entails "might \(\phi \)", and \(\phi \).

* The anaphoric potential of modalized sentences

Consider the following minimal pair, instantiating a modal variant of Rothschild's observation (i'm assuming that Andreea wearing a ring contextually entails that she has a husband).[fn:1]

#+name: modalrothschild
#+begin_exe
\ex
\begin{xlist}
\ex Andreea might have a\(^v\) husband. If she's wearing a ring, I'll ask about him\(_v\).
\ex Andreea might be married. ??If she's wearing a ring, I'll ask about him\(_v\).
\end{xlist}
#+end_exe

What this seems to indicate is that, when uttered against \(c\), \(\Diamond \exists_vH(v)\) allows \(\phi \) to introduce anaphoric information /only relative to the worlds in \(c\) at which there is an \(H\)/, but still retains worlds at which there is no \(H\). More formally:

#+name: epistemic-example
#+begin_exe
\ex \(c[\Diamond\exists_vH(v)]^+ = \begin{cases}
\begin{aligned}[t]
&\set{(w,h)|(w,g) \in c \wedge g[v]h \wedge h_v \in I_w(H)}\\
&\cup \set{(w,g) \in c|I_w(H) = \emptyset }
\end{aligned}&\exists w \in c_w[I_w(H) \neq \emptyset]\\
\emptyset &\text{otherwise} 
\end{cases}\)
#+end_exe

In Heimian pragmatics, familiarity is typically /all or nothing/ --- a variable \(v\) is either familiar relative to a file context \(c\), in which case \(v\) is defined at every \(g \in c_a\), otherwise it isn't familiar, in which case typically it is undefined at every \(g \in c_a\).

Modalized existential statements make variables /partially familiar/.

We can tweak our semantics for \(\Diamond \) to predict this behaviour. The idea is as follows: when updating an information state \(c\) with \(\Diamond \phi \), first:
- Check whether there is some part of \(c\) at which \(\phi \) is true (consistency check).
- Take the union of \(c[\phi]^+\), \(c[\phi]^-\), and \(c[\phi]^?\).
 
** New entry for might  
:PROPERTIES:
:ID:       6b6baaa1-9f2e-40b5-8915-d2dc36a5ee38
:END:

#+name: might-new
#+begin_exe
\ex \(c[\Diamond\phi]^+ = \begin{cases}
c[\phi]^+ \cup c[\phi]^- \cup c[\phi]^?&c[\phi]^+ \neq \emptyset \\
\emptyset&\text{otherwise}  
\end{cases}\)
#+end_exe

** Illustration

To illustrate concretely how this works, consider the following file context:

- \(c_1 := \set{w_a,w_b,w_\emptyset } \times g_\top \)
  
Updating \(c_1\) with "Andreea might have a\(^v\) husband", first checks wheher the true update is non-empty.  

Since the test is passed, we take the union of the true, false and unknown updates, resulting in the following updated file context:

- \(c_2 := \set{(w_a,[v \to a]),(w_b,[v \to b]),(w_\emptyset,g_\top)}\)
  
Note that \(v\) /isn't familiar/, but it might become familiar if it becomes a contextual certainty that Andreea has a husband (i.e., if \(w_\emptyset \) is eliminated). 

Just in case "Andreea is wearing a ring" contextually entails "Andreea has a husband", asserting "Andreea is wearing a ring" relative to \(c_3\) will result in an updated file context in which \(v\) is familiar.

Given ([[might-new]]) we make an interesting prediction. The following sentence should be able to make \(v\) partially familiar:

#+name: might-not
#+begin_exe
\ex Andreea might not have a\(^v\) husband.
#+end_exe

#+name: might-not
#+begin_exe
\ex \(c[\Diamond\,\neg\,\exists_vH(v)]^+ = \begin{cases}
c[\neg\,\exists_vH(v)]^+ \cup c[\neg\,\exists_vH(v)]^-&c[\neg\,\exists_vH(v)]^+ \neq \emptyset \\
\emptyset&\text{otherwise}  
\end{cases}\)
#+end_exe

Note that this is equivalent to:

#+name: might-not
#+begin_exe
\ex \(c[\Diamond\,\neg\,\exists_vH(v)]^+ = \begin{cases}
c[\exists_vH(v)]^- \cup c[\exists_vH(v)]^+&c[\exists_vH(v)]^- \neq \emptyset \\
\emptyset&\text{otherwise}  
\end{cases}\)
#+end_exe

In other words, (i) "Andreea might have a\(^v\) husband", and (ii) "Andreea might not have a\(^v\) husband" impose different consistency tests on \(c\), but they introduce the same anaphoric information if the test is passed.

A way of seeing this, is that our semantics for \(\Diamond \phi \) essentially tests \(\phi \) against \(c\), and if the test passes asserts \(\phi \vee \neg\,\phi \).

This seems to make the right predictions.

#+name: might-not2 
#+begin_exe
\ex Andreea might not have a\(^v\) husband,\\
but if she's wearing a ring, I'll ask about him\(_v\).
#+end_exe

As long as we define \(\Box \) as the dual of \(\Diamond \) this explanation should carry over to cases like the following:[fn:2] 

#+name: might-not3
#+begin_exe
\ex I'm not certain that Andreea has a\(^v\) husband,\\
but if she's wearing a ring, I'll ask about him\(_v\).
#+end_exe

The explanation relies on the following fact (just in case \(\Box \phi := \neg\,\Diamond \neg\,\phi \)):

- \(\neg\,\Box \exists_vH(v) \iff \Diamond\,\neg\,\exists_vH(v)\)

** Epistemic modals and projection

How do presuppositions project through epistemic modals?

The received wisdom is that epistemic modals are /holes/ (in the sense of [cite:@Karttunen1973]), on the basis of examples such as the following.

#+name: hole1
#+begin_exe
\ex Enrico might have stopped smoking. \(\rightsquigarrow\) /Enrico smoked in the past/
\ex Perhaps the bathroom is upstairs. \(\rightsquigarrow\) /There is a bathroom/
\ex Maybe Talin is at the party too. \(\rightsquigarrow\) /someone else is at the party/
#+end_exe

Typically, the evidence is based on /what we accommodate/ on the basis of a modalized sentence containing a presupposition trigger.

But, we know that /what is accommodated/ isn't always a reliable guide to what sentence semantically presupposes [cite:@BeaverZeevat2007;@vonFintel2008;@Geurts1996;@Fox2013;@Mandelkern2016].

*** Filtration diagnostics

Filtration diagnostics indicate that the presuppositions project /existentially/ in \(\Diamond \phi \) - in other words, if \(\phi \) presupposes \(\pi \), then "possibly \(\phi \)" presupposes "possibly \(\pi \)";[fn:3] none of the examples in ([[cond1]]-[[cond3]]) inherit presuppositions from the consequent. 

#+name: conditionals 
#+begin_exe
\ex If it's possible that Enrico was a smoker, it's possible that he has stopped smoking.<<cond1>>
\ex If it's possible there's a bathroom, then it's possible the bathroom is upstairs.<<cond2>>
\ex If it's possible that Geordie is at the party, then maybe Talin is at the party too.<<cond3>>
#+end_exe

One possible response is that in all such cases, the presupposition in the consequent is /locally accommodated/ within the scope of the existential modal, but the following examples speak against local accommodation; the examples in ([[cond1]]-[[cond3]]) inherit their presupposition from the consequent.

#+name: conditionals2
#+begin_exe
\ex If it's possible that Enrico arrived early, it's possible that he stopped smoking.<<condd1>>
\ex If it's possible that this house was renovated, then it's possible the bathroom is upstairs.<<condd2>>
\ex If it's possible that the dresscode is casual, then maybe Talin is at the party too.<<condd3>>
#+end_exe

The same point can be made using disjunctions:

#+name: disjunctions
#+begin_exe
\ex Either it's impossible that Enrico wasn't a smoker, or it's possible that he stopped.
\ex Either it's impossible that there's a bathroom, or it's possible that the bathroom is upstairs.
\ex Either it's impossible that Geordie is at the party, or maybe Talin is at the party too.
#+end_exe

With respect to what various dynamic proposals for epistemic modals predict - we haven't encoded non-anaphoric presuppositions explicitly into our grammar, but it's easy to see what the predictions would be were we to do so.

Veltman's test semantics perform a consistency test on the /entire information state/; this straightforwardly predicts that \(c[\Diamond\phi]\) is only defined if \(c[\phi]\) is defined (i.e., presuppositions project).

Our revised consistency test for /might/ however predicts existential projection, since all it requires is that the positive extension is non-empty.

#+transclude: [[id:6b6baaa1-9f2e-40b5-8915-d2dc36a5ee38]] 
*** Existential projection and conjunctive possibility statements

Recall our puzzling sentence:

#+name: possible-bathroom
#+begin_exe
\ex Maybe there is no bathroom, and maybe it's upstairs.\\
\(\Diamond\,\neg\,\exists_vB(v) \wedge \Diamond\,U(v)\)
#+end_exe

Now that we've established (a) the potential of modalized sentence to introduce (partially familiar) variables, (b) existential projection, we're in a position to explain ([[possible-bathroom]]).

Consider an information state \(c_1\) consisting of the following worlds paired with the initial assignment \(g_\top\):

- \(w_d\): there's a bathroom \(b\) downstairs.
- \(w_u\): there's a bathroom \(b\) upstairs.
- \(w_\emptyset \): there's no bathroom.
  
First, let's figure out how to compute the conjunctive update:

#+name: step1
#+begin_exe
\ex \(c_1[\Diamond\,\neg\,\exists_vB(v) \wedge \Diamond\,U(v)]^+ = c_1[\Diamond\,\neg\,\exists_vB(v)]^+[\Diamond\,U(v)]^+\)
#+end_exe

Now, we'll update \(c_1\) with the first conjunct.

- This checks that there's part of \(c_1\) at which there's no bathroom.
- Since this test is passed, we now take the union of \(c_1[.]^{+,-,?}\), giving rise to \(c_2\)

#+name: step2
#+begin_exe
\ex \(c_1[\Diamond\,\neg\,\exists_vB(v)]^+ = \set{(w_d,[v \to b]),(w_u,[v \to b]),(w_\emptyset,[])} := c_2\)
#+end_exe
  
Now we can update \(c_2\) with the second conjunct.

First, we perform the consistency test. This just requires that \(U(v)\) is true at one of the evaluation points in \(c_2\). The test succeeds, since:

#+name: step3
#+begin_exe
\ex \(c_2[U(v)]^+ = \set{(w_u,[v \to b])}\)
#+end_exe

Now, we compute the information introduced by the modalized second conjunct - since the consistency test is passed, the modalized second conjunct introduces no information:

#+name: step4
#+begin_exe
\ex \(c_2[\Diamond U(v)]^+ = \set{(w_d,[v \to b]),(w_u,[v \to b]),(w_\emptyset,[])} := c_3\)
#+end_exe

In this context, the following would be equivalent:

#+name: might-be
#+begin_exe
\ex There might be no\(^v\) bathroom, it\(_v\) might be downstairs, and it\(_v\) might be upstairs.
\ex There might be a\(^{v}\) bathroom, and it\(_v\) might be upstairs.
#+end_exe

Note that we predict /weak, existential truth conditions/ for conjunctive possibility statements like this. This seems correct.

#+name: weak
#+begin_exe
\ex Maybe Sarah didn't buy a\(^v\) drink, and maybe she bought another drink right after it\(_v\).
\ex Mary Sarah bought a\(^v\) drink, and maybe she bought another drink right after it\(_v\).
#+end_exe

*** Impossible discourse referents

A loose end - saying what the negative extension of a modalized statement is, given ([[might-new]]). In a multivalent system, we have some freedom.

Currently we predict strong projection, although I'm not sure this is right.

#+name: impossible
#+begin_exe
\ex There might be a\(^v\) bathroom, but it's impossible/there's no way that it\(_v\)'s upstairs.
\ex ??There might be a\(^v\) bathroom, but it\(_v\)'s not upstairs.
#+end_exe

And we want to still allow modalized sentences to introduce anaphoric information under negation.

#+name: impossible2
#+begin_exe
\ex It's not possible that there's no\(^v\) bathroom; it\(_v\)'s upstairs!\\
\(\neg\,\Diamond\,\neg\exists_vB(v) \wedge U(v)\)
\ex There must be a\(^v\) bathroom; I just saw it\(_v\)!\\
\(\Box\,\exists_vB(v)\)
#+end_exe

A weaker semantics for \(\neg\,\Diamond\,\phi \) would impose two checks:
- No possibility in \(c\) is consistent with \(\phi \).
- Some possibility in \(c\) is consistent with \(\neg\,\phi \).

#+name: must-anaph
#+begin_exe
\ex \(c[\Diamond\phi]^- = \begin{cases}
c[\phi]^{+,-,?}}&c[\Diamond\phi]^+ = \emptyset \wedge c[\phi]^- \neq \emptyset]\\
\emptyset&\text{otherwise}  
\end{cases}\)
#+end_exe

This directly accounts for ([[impossible2]]). First, let's decide how to compute the conjunctive update.

#+name: 
#+begin_exe
\ex \(c[\neg\,\Diamond\,\neg\,\exists_vB(v)]^+[U(v)]^+ \iff c[\Diamond\neg\exists_vB(v)]^-[U(v)]^+\)
#+end_exe

The update induced by the first conjunct is only non-empty if there are no non-bathroom worlds in \(c\). If there are no non-bathroom words, then we update all the bathroom worlds with a bathroom discourse referent \(v\). This makes \(v\) familiar, if we assume bivalence.

Defining the unknown extension of /might/ is now straightforward.

#+name: must-undefined
#+begin_exe
\ex \(c[\Diamond\phi]^? = \begin{cases}
c&c[\Diamond\phi]^+ = \emptyset \wedge c[\Diamond\phi]^- = \emptyset\\
\emptyset &\text{otherwise} 
\end{cases}\)
#+end_exe

* Free choice

** Free choice with anaphora

As we discussed last week, no theories of free choice can capture /free choice with anaphora/.

#+name: fc-anaphora
#+begin_exe
\ex It's possible that either there's no bathroom, or it's upstairs.
\begin{xlist}
\ex It's possible that there's no bathroom.
\ex It's possible that there's a bathroom upstairs.
\end{xlist}
#+end_exe

Here, we'll show that by extending Goldstein's dynamic account [cite:@Goldstein2019], we can capture free choice with anaphora within the current setting.

The idea will be that we can distinguish formally between /ways of verifying/ a disjunctive sentence, tracking the truth of the first and second disjuncts respectively. 

#+name: verification1
#+begin_exe
\ex \(c[\phi \vee \psi]^{1} = c[\phi]^{+}[\psi]^{+,-,?}\)
\ex \(c[\phi \vee \psi]^{2} = c[\phi]^{+,-,?}[\psi]^{+}\)
#+end_exe

We'll enrich our semantics for disjunction by adding the requirement that /both verification strategies for disjunction are contextually viable/:

#+name: disjunction-new
#+begin_exe
\ex \(c[\phi \vee \psi]^+ = c[\phi \vee \psi]^{1} \cup c[\phi \vee \psi]^{2}\text{ if }c[\phi \vee \psi]^{1},c[\phi \vee \psi]^{2} \neq \emptyset\text{ else }\emptyset \)
#+end_exe

Let's see how this combines with our entry for /might/ to derive free choice with anaphora.

#+name: free-choice
#+begin_exe
\ex \(\Diamond (\neg\,\exists_vB(v) \vee U(v))\)
#+end_exe

Recall: /might/ imposes a requirement on \(c\): namely, there should be a part of \(c\) at which \(\neg\exists_vB(v) \vee \psi\) is true.

#+name: consist
#+begin_exe
\ex \(c[\Diamond (\neg\,\exists_vB(v) \vee U(v))]^+ \neq \emptyset\text{ if }c[\neg\exists_vB(v) \vee U(v)]^+ \neq \emptyset\)
#+end_exe

This will hold just in case there is some part of \(c\) which contextually entails there's no bathroom, and some part of \(c\) which contextually entails that there's a bathroom upstairs.

(N.b. we still need to say something about the negative extension of disjunction to get double prohibition).

** Negative free choice with anaphora

#+name: negative-free-choice
#+begin_exe
\ex I'm not certain that John both bought a\(^v\) book and read it\(_v\).
\begin{xlist}
\ex I'm not certain that John bought a\(^v\) book.
\ex If John bought a book, I'm not certain that he read it\(_v\). 
\end{xlist}
#+end_exe

We can require that both ways of falsifing a conjunction are possible.

* TODO Going inquisitive

* References

#+print_bibliography:

* Footnotes
[fn:3] For reasons unknown to me, /it's possible that/ is the only instantiation of \(\Diamond \) that comfortably embeds in the antecedent of a conditional. 

[fn:2] Thanks to Filipe for bringing up this data.
[fn:1] Thanks to Filipe for help with this data.

* File local variables                                             :noexport:
 
# Local Variables:
# mode: org
# org-latex-default-packages-alist: nil
# org-latex-with-hyperref: nil
# End:

