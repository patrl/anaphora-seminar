#+title: Disjunction, possibility, and hypothetical discourse referents 
#+author: Patrick D. Elliott 
#+bibliography: ../../bibliography/master.bib
#+setupfile: handout-template.org
#+OPTIONS: ':t
#+cite_export: biblatex

* Notices

Class next week is cancelled - I'm participating in the workshop /Dynamics in Logic and Language/ (Tsinghua University), and giving a talk next Monday morning entitled "Disjunction in a predictive theory of anaphora".

I'll be talking about material related to the topic of this seminar, so please consider registering (there's also an invited talk by Hans Kamp shortly after mine).

Registration is free, and the link is: http://tsinghualogic.net/JRC/?page_id=4555

Upcoming classes:

- April 11: Two possibilities: (i) strong/weak readings of donkey anaphora [cite:@Kanazawa1994;@ChampollionEtAl2019], (ii) inquisitive dynamic semantics [cite:@DotlacilRoelofsen2019;@DotlacilRoelofsen2021].
- April 18: No class (Patriot's day).
- April 25: Quantification and discourse plurals.
- May 2: Filipe on postsuppositions.
- May 9: TBC.


* Roadmap for today's class  

- A presentation of EDS as a multivalent semantics for a first-order calculus. This will be significantly easier to reason about, and allow us to abstract away from compositional details.
- More on the ignorance inferences associated with disjunction, which were crucial in our explanation for external staticity. I'll suggest that a very general issue arises when we consider simplification-based inferences in light of anaphoric dependencies.
- Deriving internal staticity with disjunction, and the relationship to Singh's constraint.
- Finally, we'll extend the empirical remit of EDS to cases involving epistemic modals and modal subordination. Several interesting issues will arise as we attempt to incorporate modality into EDS.

* First order EDS

A concise presentation of EDS as a semantics for a first order calculus.

In the relational presentation, we explicitly list pairs of assignments which (i) verify a sentence, (ii) falsify a sentence, and (iii) those against which the truth of a sentence is uncertain. (iii) is not an "elsewhere" case - hence, the first layer of partiality.

To appreciate the isomorphism between this presentation, and the previous presentation, consider that a trivalent relational semantics can be framed instead as a set of relations, each paired with one of three truth values.

#+name: def:eds-stat
#+begin_exe
\ex Static semantics for atomic sentences:\\
\([P(v_1,\ldots,v_n)]^{w,g} = \begin{cases} \mathbf{defined} &  g(v_1), \ldots ,g(v_n) \neq \#_e\\
\mathbf{true} & [P(v_1,\ldots,v_n)]^{w,g}\text{ is \textbf{defined} and }\langle g(v_1),\ldots,g(v_n)\rangle \in I_w(P)
\end{cases}\)
#+end_exe

For recursively define \(\eval*[w][+]{.}, \eval*[w][-]{.}, \eval*[w][u]{.}\) for each sentence of EDS.

For atomic sentences, we guarantee that the \(u\)-extension is a test (c.f. partial DPL; [cite:@vandenBerg1996]).

#+name: def:eds-atom
#+begin_exe
\ex Atomic sentences in EDS:
\begin{xlist}
\ex \(\eval*[w][+]{P(v_1,\ldots,v_n)} := \set{(g,h)|g = h \wedge |P(v_1,\ldots,v_n)|^{w,h}\text{ is \textbf{true}}}\)
\ex \(\eval*[w][-]{P(v_1,\ldots,v_n)} := \set{(g,h)|g = h \wedge |P(v_1,\ldots,v_n)|^{w,h} \text{ is \textbf{false}} }\)
\ex \(\eval*[w][u]{P(v_1,\ldots,v_n)} := \set{(g,h)|g = h \wedge |P(v_1,\ldots,v_n)|^{w,h}\text{ is \textbf{undefined}} }\)
\end{xlist}
#+end_exe

Truth and falsity:

- \(|\phi|^{w,g}\text{ is \textbf{true} if }\set{h |(g,h) \in \eval*[w][+]{\phi }} \neq \emptyset \)
- \(|\phi|^{w,g}\text{ is \textbf{false} if }|\phi|^{w,g}\text{ is not \textbf{true} and } \set{h |(g,h) \in \eval*[w][-]{\phi }} \neq \emptyset\)
- \(|\phi |^{w,g}\text{ is \textbf{neither} otherwise}\)
  
For negative sentences, verification and falsification are flipped, presuppositions project.

#+name: def:eds-neg
#+begin_exe
\ex Negative sentences:
\begin{xlist} 
\ex \(\eval*[w][+]{\neg \phi } := \eval*[w][-]{\phi }\)
\ex \(\eval*[w][-]{\neg \phi } := \eval*[w][+]{\phi }\)
\ex\(\eval*[w][u]{\neg \phi } := \eval*[w][u]{\phi }\)
\end{xlist}
#+end_exe

For conjunctive sentences.

- Verification is computed by taking the DPL conjunction (i.e. relational composition; \(.\,\circ\,.\)[fn:7]) of the positive extensions. 
- For falsification, we take the union of ways of dynamically falsifying the conjunctive statement.
- Presuppositions project as in strong Kleene.

#+name: def:eds-conk
#+begin_exe
\ex Conjunctive sentences:
\begin{xlist}
\ex \(\eval*[w][+]{\phi \wedge \psi} := \eval*[w][+]{\phi } \circ \eval*[w][+]{\psi}\)
\ex \(\eval*[w][-]{\phi \wedge \psi} := \begin{aligned}[t]
&\eval*[w][-]{\phi} \circ \eval*[w][+,-,u]{\psi}\\
&\cup \eval*[w][+,u]{\phi} \circ \eval*[w][-]{\psi}
\end{aligned}\)
\ex \(\eval*[w][u]{\phi \wedge \psi} := \begin{aligned}[t]
&\eval*[w][+]{\phi } \circ \eval*[w][u]{\psi}\\
&\cup \eval*[w][u]{\phi } \circ \eval*[w][+,u]{\psi}
\end{aligned}\)
\end{xlist}
#+end_exe

Random assignment is a tautology, i.e., it only has a positive extension.

#+name: def:eds-rand
#+begin_exe
\ex Random assignment:
\begin{xlist}
\ex \(\eval*[w][+]{\varepsilon_v} := \set{(g,h)|g[v]h}\)
\ex \(\eval*[w][-]{\varepsilon_v} := \emptyset\)
\ex \(\eval*[w][u]{\varepsilon_v} := \emptyset\)
\end{xlist}
#+end_exe

Positive closure ensures that no anaphoric information is introduced if the prejacent is false.

#+name: def:eds-dag
#+begin_exe
\ex Positive closure:
\begin{xlist}
\ex \(\eval*[w][+]{\dag\phi } := \eval*[w][+]{\phi}\)
\ex \(\eval*[w][-]{\dag\phi } := \set{(g,h)|g = h \wedge |\phi|^{w,g}\text{ is \textbf{false}} }\)
\ex \(\eval*[w][u]{\dag\phi } := \eval*[w][u]{\phi}\)
\end{xlist}
#+end_exe

#+name: exist
#+begin_exe
\ex Existential quantification:\\
\(\exists_v\phi := \varepsilon_v \wedge \phi\)
#+end_exe

** Some reminders

Unlike in DPL, we must distinguish between expressions being tests with respect to their positive vs. their negative contribution.

- \(\phi\) is a /(positive) test/ if \(\forall (g,h) \in \eval*[w][+]{\phi }[g = h]\).
- \(\phi\) is a /negative test/ if \(\forall (g,h) \in \eval*[w][-]{\phi }[g = h]\)
  
Some useful facts:

- If \(\phi\) is a negative test, then \(\neg\phi \) is a test.
- If \(\dag(\phi)\) is a negative test.
- \(\neg(\dag(\phi))\) is a test.
  
This allows us to see why existentials don't commute with negation in EDS:

- \(\neg(\exists_v\phi)\) is a test (cf. external staticity of negation in DPL).
  
Egli's theorem doesn't hold in EDS:

\[\exists_v\phi \wedge \psi \not\iff  \exists_v[\phi \wedge \psi]\]

But a more limited version of Egli's theorem does hold - Egli's positive equivalence:

\[\eval*[w][+]{\exists_v\phi \wedge \psi} = \eval*[w][+]{\exists_v[\phi \wedge \psi]}\]

* More on disjunction: ignorance and internal staticity 

** EDS disjunction

Let's recast our semantics for disjunction in first-order EDS.

- Verification is computed by taking th union of ways of dynamically verifying the conjunctive statement.
- For falsification, we just take the DPL conjunction of the negative extensions.
- Presuppositions project as in strong Kleene.

#+name: def:eds-disj
#+begin_exe
\ex Disjunctive sentences:
\begin{xlist}
\ex \(\eval*[w][+]{\phi \vee \psi} := \begin{aligned}[t]
&\eval*[w][+]{\phi } \circ \eval*[w][+,-,u]{\psi}\\
&\cup \eval*[w][-,u]{\phi } \circ \eval*[w][+]{\psi}\\
\end{aligned}
\)
\ex \(\eval*[w][-]{\phi \vee \psi} := \eval*[w][-]{\phi } \circ \eval*[w][-]{\psi}\)
\ex \(\eval*[w][u]{\phi \vee \psi} := \begin{aligned}[t]
&\eval*[w][-]{\phi } \circ \eval*[w][u]{\psi}\\
&\cup \eval*[w][u]{\phi } \circ \eval*[w][-,u]{\psi}
\end{aligned}\)
\end{xlist}
#+end_exe

Virtue: bathroom disjunctions.

#+name: bathroom1
#+begin_exe
\ex \(\neg\exists_v[B(v)] \vee U(v)\)
#+end_exe

#+begin_tipblock
If the positive extension of the first disjunct is non-empty, then the second disjunct only has a non-empty undefined extension. The second disjunct only has a non-empty postitive extension, if the first has a non-empty negative extension.
#+end_tipblock

Depending on the model, the disjunctive sentence either introduces a bathroom upstairs discourse referent (if there is a bathroom upstairs), and otherwise is a test.

** Disjunction, triviality, and ignorance

Remember, we explained the apparent /external staticity/ of disjunction (and it exceptions) by recourse to the independently-motivated requirement that each disjunct is a /real possibility/.

For the following discussion, it will be important to make precise exactly what this means.

#+name: def-mod1
#+begin_definition
*Contingency requirement* (first attempt). A sentence of the form \(\phi \vee \psi\) is /felicitous/ when asserted in a context \(c\) iff both \(c_w[\phi]\) and \(c_w[\psi]\) are non-empty proper subsets of \(c_w\).[fn:3]
#+end_definition

#+begin_tipblock
A direct consequence: a disjunctive sentence is /infelicitous/ in \(c\) if either disjunct is contextually trivial.
#+end_tipblock

In a bivalent setting, the principle in ([[def-mod1]]) will have the desired effect.

#+name: triv1
#+begin_exe
\ex Context: /Josie has just said "I have food poisoning"./
\begin{xlist}
\ex ??Either Josie is sick or we'll eat out tonight.
\ex ??Either Josie is well or we'll stay home tonight.
\ex Either Josie is well by 7pm or we'll stay home tonight.
\end{xlist}
#+end_exe

If we take presuppositions (anaphoric or otherwise) into account, we see that ([[def-mod1]]) is too strong.

Consider our Stalnakerian bridge principle:.

#+begin_definition
Update in EDS.

\[c[\phi] = \begin{cases}
    \bigcup\limits_{(w,g) \in c}\set{(w,h)|(g,h) \in \eval*[w][+]{\phi }}&\forall (w,g) \in c[|\phi|^{w,g} \text{ is \textbf{true}}\text{ or }|\phi|^{w,g}\text{ is \textbf{false}}] \\
    \text{undefined}  &\text{otherwise}
    \end{cases}
\]
#+end_definition

If either of the disjuncts is /presuppositional/ (i.e., contains a pronoun/free variable), then the condition in ([[def-mod1]]) will only be met if the presupposition is satisfied throughout the context.[fn:1] 

This will place far-too-strong requirements on /bathroom disjunctions/, such as "Either there is no\(^v\) bathroom, or it\(_v\)'s upstairs" - the condition in ([[def-mod1]]) predicts that this should require \(v\) to be defined throughout the context.

Locally accommodating the presupposition (were this independently possible for pronouns) doesn't help either, as this gives rise to a /too weak/ requirement - namely:

- /It's a real possibility that there is no bathroom./
- /It's a real possibility that something is upstairs./

#+begin_warningblock
There is a possibility which we can immediately dismiss: whenever we derive an ignorance inference, we have an e-type pronoun [cite:@Heim1990], i.e., "Either there is no bathroom or *the bathroom* is upstairs". This takes of getting the right descriptive material in the second disjunct, BUT as emphasized by [cite:@MandelkernRothschild2020] there is no conceivable account of bathroom anaphora in a situation-based framework which doesn't make use of an /ad-hoc/ semantics for disjunction in order to avoid unwanted uniqueness inferences ("Mary either didn't order a\(^v\) drink, or ordered a second one right after it\(_v\).").
#+end_warningblock

The heart of the problem with the condition in ([[def-mod1]]) is that it ignores the possibility of dependencies between disjuncts. 

Another way of thinking about it: when an anaphoric dependency exists between disjuncts, the disjunct containing the variable is no longer a truthmaker of the disjunction as a whole.

#+begin_tipblock
The intuition behind the solution: disjunction dynamically introduces two contextual alternatives (i) the part of \(c[\phi \vee \psi]\) in which the disjunction is verified by the first disjunct, and (ii) the part of \(c[\phi \vee \psi]\) in which the disjunction is verified by the second disjunct. Neither way of verifying the disjunction should be contextually trivial.[fn:2]
#+end_tipblock

In order to isolate the parts of the context corresponding to verifying each disjunct, we hold the positive extension of each disjunct constant. 

It's important to note that \(c[\phi \vee \psi]_1\) and \(c[\phi \vee \psi]_2\) may overlap, just in case the disjuncts are contextually compatible (we'll address this when we discuss internal staticity). 

- \(c[\phi \vee \psi]_{1}:= \bigcup\limits_{(w,g) \in c}\set{(w,h)|(g,h) \in \eval*[w][+]{\phi } \circ \eval*[w][+,-,u]{\psi}}\)
- \(c[\phi \vee \psi]_{2} := \bigcup\limits_{(w,g) \in c}\set{(w,h)|(g,h) \in \eval*[w][+,-,u]{\phi } \circ \eval*[w][+]{\psi}}\)

Let's illustrate how this works:

- \(w_{bu}\): \(b\) is a bathroom upstairs.  
- \(w_{bd}\): \(b\) is a bathroom downstairs.
- \(w_\emptyset \): there are no bathrooms.
  
Initial file context \(c_\top \): \(\set{w_{bu},w_{bd},w_\emptyset } \times g_\top \)

- \(c[\neg\exists_v[B(v)] \vee U(v)] = \set{(w_{bu},[v \to b]),(w_\emptyset,[])}\)
- \(c[\neg\exists_v[B(v)] \vee U(v)]_1 = \set{(w_\emptyset,[])}\)
- \(c[\neg\exists_v[B(v)] \vee U(v)]_2 = \set{(w_{bu},[v \to b])}\)

#+name: def-mod2
#+begin_definition
*Contingency requirement* (second attempt). A sentence of the form \(\phi \vee \psi\) is /felicitous/ when asserted in a context \(c\) iff neither way of verifying the disjunction would be trivial, i.e.:

- \(c_w[\phi \vee \psi]_1 \) is a non-empty proper subset of \(c_w\).
- \(c_w[\phi \vee \psi]_2 \) is a non-empty proper subset of \(c_w\).
  
#+end_definition

Constraints that ([[def-mod2]]) places on the context in light of \(\neg\exists_v[B(v)] \vee U(v)\).

- If it were contextually trivial that are no bathroom, \(c_w[\phi \vee \psi]_1 = c_w\), or is empty.
- If it were contextually trivial that there's a bathroom upstairs, then \(c_w[\phi \vee \psi]_2 = c_w\), or is empty.
- Importantly, note that \(\set{w_\emptyset, w_{bu}}\) is compatible with the requirements in ([[def-mod2]]), but in such a context the disjunctive assertion would be informationally redundant. 

This will give rise to the welcome prediction that "Either there is no\(ᵛ\) bathroom or it\(ᵥ\)'s upstairs" is felicitous \(c\), just in case either:

- \(c\) is compatible with (but doesn't entail) there being no bathroom.
- \(c\) is compatible with (but doesn't entail) there being a bathroom upstairs.

For cases where there are no dependencies between disjuncts, ([[def-mod2]]) simply subsumes the initial formulation (hopefully).

** Simplification and anaphora

#+begin_warningblock
How do we derive ([[def-mod2]]) from pragmatic reasoning about alternatives?
#+end_warningblock

It's important to develop a more general story, since other simplification-based inferences break down in the presence of anaphoric dependencies (watch this space).[fn:6]

Free choice:

#+name: free-choice
#+begin_exe
\ex You're allowed to either write no\(^v\) term paper, or submit it\(_v\) by midnight.
#+end_exe

Note that a naïve free choice inference doesn't go through, since the pronoun becomes unbound.

#+name: fc-2
#+begin_exe
\ex 
\begin{xlist}
\ex \(\implies \) \textit{You're allowed to write no term paper}
\ex \(\not\implies\) \textit{You're allowed to submit it by midnight}
\ex \(\implies\) \textit{You're allowed to write a\(^v\) term paper and submit it\(_v\) by midnight}
\end{xlist}
#+end_exe

I don't know of any account of free choice which can accommodate this; especially hard for implicature accounts which rely on formal alternatives [cite:@Fox2007;@Bar-LevFox2017].

Other inferences which are accounted for in terms of simplification face similar problems [cite:@CrnicEtAl2015].

#+name: dist1
#+begin_exe
\ex Everyone either didn't write a term paper or submitted it by midnight.
\begin{xlist}
\ex \(\implies\) \textit{Some people didn't write a term paper.}
\ex \(\not\implies\) \textit{Some people submitted it by midnight.}
\ex \(\implies\) \textit{Some people wrote a term paper and submitted it by midnight.}
\end{xlist}
#+end_exe

Related issues:

- Ignorance inferences associated with the antecedent and consequent of a conditional, in the presence of donkey anaphora.
- Ignorance inferences associated with a negated conjunctive sentence, in the presence of discourse anaphora.
  
Notice there's a related problem with propositional anaphora to a disjunct:

#+name: prop-anaph
#+begin_exe
\ex Either there's no bathroom, or it's upstairs. If *the latter*, then we'll see it soon.
#+end_exe

The recipe I provided earlier for computing the contextual alternatives introduced by disjunction can make sense of the meaning of *the latter*.

** Internal staticity and Hurford's constraint

Anaphoric relations between disjuncts are disallowed [cite:@GroenendijkStokhof1991], i.e., ([[int-stat]]) presupposes that \(v\) is contextually defined.

#+name: int-stat
#+begin_exe
\ex ??Either someone\(^v\) is in the audience, or they\(_v\)'re sitting down.
#+end_exe

#+name: int-stat-fs
#+begin_exe
\ex \(\exists^v[A(v)] \vee S(v)\)
#+end_exe

In EDS, disjunction is internally dynamic, just like every other logical connective - how can we rule out ([[int-stat]])?

Let's compute its positive extension. First, some salient points:

- If the first disjunct is true, the second is guaranteed to be defined (i.e., have an empty \(u\)-extension, so we can ignore it).
- The first disjunct is /always/ defined (we can ignore its \(u\)-extension).
- If the first disjunct is false, whether or not the second disjunct is true will depend on the input assignment.

#+name: pos-ext-disj
#+begin_exe
\ex \(\eval*[w][+]{\exists^v[A(v)] \vee S(v)} = \begin{aligned}[t]
&\eval*[w][+]{\exists_v[A(v)]} \circ \eval*[w][+,-]{S(v)}\\
&\cup \eval*[w][-]{\exists_v[A(v)]} \circ \eval*[w][+]{S(v)}
\end{aligned}\)
\ex \(= \set{(g,h)|g[v]h \wedge g(v) \in I_w(A)} \cup \set{(g,h)|g = h \wedge I_w(A) = \emptyset \wedge h(v) \in I_w(S)}\)
#+end_exe

So, "Either someone\(^v\) is in the audience or they\(_v\)'re sitting down", either introduces an audience member dref \(v\), if there are audience members, or if there are no audience members asserts that \(v\) is sitting down.

Since we'll consider the conditions under which ([[int-stat-fs]]) is assertable, let's also compute its negative extension.

- If the first disjunct is false, whether or not the second disjunct is false will depend on the input assignment.

#+name: neg-ext-disj
#+begin_exe
\ex \(\eval*[w][-]{\exists^v[A(v)] \vee S(v)} = 
\eval*[w][-]{\exists_v[A(v)]} \circ \eval*[w][-]{S(v)}\)
\ex \(= \set{(g,h)|g = h \wedge I_w(A) = \emptyset \wedge h(v) \notin I_w(S)}\)
#+end_exe

So, "Either someone\(^v\) is in the audience or they're sitting down" is /false/ if there are no audience members and \(v\) isn't sitting down.

Let's consider what it would mean to assert ([[int-stat-fs]]) in a concrete context.

Recall our Stalnakerian bridge principle: What requirements does ([[int-stat-fs]]) place on the context? Every world assignment pair \((w,g)\) should be s.t., either:

- \(w\) is an /audience-member world/.
- \(w\) is a non-audience member world, and \(g(v)\) is defined.
  
Let's give a concrete example.

- \(w_d\): \(a\) is an audience member sitting down.
- \(w_u\): \(a\) is an audience member standing up.
- \(w_{d'}\): nobody is in the audience and \(a\) is sitting down.
- \(w_{u'}\): nobody is in the audience and \(a\) is standing up.
  
In a context \(\set{w_d,w_u,w_{d'},w_{u'}} \times g_\top \), ([[int-stat]]) will be undefined due to the presupposition /if nobody is in the audience \(g(v)\) is defined/. 

If we remove the worlds in which nobody is in the audience, then ([[int-stat]]) is informationally redundant.

Let's assume that we do someone manage to associate just the audienceless worlds with a discourse referent \(a\).

- \(c' := \set{(w_d,[]),(w_u,[]),(w_{d'},[v \to a]),(w_{u'},[v \to a])}\)
  
Updating \(c'\) with ([[int-stat]]) will give the following updated context. The only \((w,g)\) which is eliminated is the one in which nobody is in the audience in and \(g(v)\) is standing up.

- \(c'[\exists_v[A(v)] \vee S(v)] := \set{(w_d,[v \to a]),(w_u,[v \to a]),(w_{d'},[v \to a])}\)
  
Now, let's consider the parts of the updated context that each disjunct is responsible for:

- \(c'[\exists_v[A(v)] \vee S(v)]_1 := \set{(w_d,[v \to a]),(w_u,[v \to a])}\)
- \(c'[\exists_v[A(v)] \vee S(v)]_2 := \set{(w_d,[v \to a]),(w_{d'},[v \to a])}\)
  
Note that the resulting information states are overlapping, due to the existence of a world in which someone is in the audience sitting down \(w_d\) (i.e., the disjuncts are compatible).

[cite:@Singh2008] argues that a disjunction is infelicitous if the disjuncts are contextually compatible.

#+name: singh
#+begin_exe
\ex ??John is in Russia or Asia.
\ex Context: /the diagram consists of two overlapping circles, A and B/.\\
??The mark is in A or B.
#+end_exe

It follows that ([[int-stat]]) can't convey that there is a person who is both in the audience and sitting down.

#+name: def-mod2
#+begin_definition
*Contingency/incompatibility requirement* (first attempt). A sentence of the form \(\phi \vee \psi\) is /felicitous/ when asserted in a context \(c\) iff neither way of verifying the disjunction would be trivial, and the verification strategies are mutually incompatible, i.e.:

- \(c_w[\phi \vee \psi]_1 \) is a non-empty proper subset of \(c_w\).
- \(c_w[\phi \vee \psi]_2 \) is a non-empty proper subset of \(c_w\).
- \(c_w[\phi \vee \psi]_1 \cap c_w[\phi \vee \psi]_2 = \emptyset\).
  
#+end_definition



* Modality and anaphora

** Some interactions between modals and anaphora

#+begin_tipblock
*A generalization that emerges from EDS:* an assertion of a sentence \(\phi \) containing an existential statement "a\(^v\) linguist \(P\)-ed" introduces a dref \(v\) if the assertion is accepted and contextually entails the existence of a linguist that \(P\)-ed.
#+end_tipblock

Interaction with modality draws this generalization into question.

Modal subordination and anaphora [cite:@Roberts1989]:

#+name: hypothetical2
#+begin_exe
\ex Maybe there's a\(^v\) bathroom, and maybe it\(_v\)'s upstairs.
\ex Maybe there's a\(^v\) bathroom. It\(_v\) would be upstairs.
\ex There might be a\(^v\) bathroom, and it\(_v\) might be upstairs.
\ex There might be a\(^v\) bathroom. It\(_v\) would be upstairs.
#+end_exe

Not possible with disjunction(?):

#+begin_exe
\ex ??Maybe there's a\(^v\) bathroom, or maybe it\(_v\)'s upstairs.
\ex ??There might be a\(^v\) bathroom, or it\(_v\) might be upstairs.
#+end_exe

Surprisingly, conjunctive possibility statements can pattern with disjunction: 

#+name: hypothetical1
#+begin_exe
\ex There might be no\(^v\) bathroom, and it\(_v\) might be upstairs.
\ex Maybe there's no\(^v\) bathroom, and maybe it\(_v\)'s upstairs. 
\ex Either There's no\(^v\) bathroom, or it\(_v\)'s upstairs.
#+end_exe

Note that this parallel is perhaps unsurprising, given modal theories of disjunction which validate \(\phi \vee \psi \vdash \Diamond\phi \wedge \Diamond\psi\) [cite:@Zimmermann2000;@Geurts2005;@Goldstein2019].

Modal subordination with negation; data from [cite:@Hofmann2019]:

#+name: hypothetical3
#+begin_exe
\ex There is no\(^v\) bathroom in this house. It\(_v\) would be easier to find.
#+end_exe

** Epistemic modality in dynamic semantics

*** Initial motivations: disagreement

The classical relational semantics for epistemic possibility [cite:@Kratzer2012].

#+name: ep-mod
#+begin_exe
\ex \(\eval*[w,f]{\Diamond \phi } := \text{\textbf{true} iff }\exists w' \in f(w)[\eval*[w']{\phi }\text{ is \textbf{true}} ] \)
#+end_exe


The parameter \(f\) is taken to be determined by the conversational context, and maps each world \(w\) to the set of worlds compatible with what is known in \(w\).

Known by who? One salient possibility is the speaker.[fn:5]

A fatal problem for this view ([cite:@Hawthorne2004]; data from [cite:@Rudin2021]):

#+name: hawthorne
#+begin_exe
\ex 
\begin{xlist}
\ex Andrea: Paul might have been at the party last night.
\ex Bertrand: You're wrong, he was in Barbados. 
\end{xlist}
#+end_exe

#+begin_quote
"The puzzle is that no way of pinning the relevant knowledge state down
seems to be able to explain both why we are in a position to make the epistemic “might” claims we seem to be in a position to make, and also why it is often reasonable to disagree with “might” claims made by others" [cite:@Stalnaker2014]
#+end_quote

N.b. epistemic /must/ is classically treated as the dual of /might/.

*** Sensitivity to local context

Following data from [cite:@Rothschild2021]. Disjunction:

#+name: roth1
#+begin_exe
\ex Either John is here or he must be in China.
\begin{xlist}
\ex \(\implies\) Either John is here, or else it must be that he's not here and is in China.
\ex \(\implies \) Either John is here, or he's in China.
\ex \(\not\implies \) Either John is here, or some contextual body of information entails that he is in China.
\end{xlist}
#+end_exe

Conditionals:

#+name: roth2
#+begin_exe
\ex If John isn't here, he must be in China.
\begin{xlist}
\ex \(\implies \) It must be that if John isn't here, he's in China.
\ex \(\implies \) If John isn't here, he's in China.
\ex \(\not\implies \) If John isn't here, then some contextual body of information entails that he is in China.
\end{xlist}
#+end_exe

Conjunction:

#+name: roth2
#+begin_exe
\ex Either John is in the US, or else John is in France and Chloe must be with him.
\begin{xlist}
\ex \(\implies \) Either John is in the US, or else it must be that John is in France and Chloe is with him.
\ex \(\implies \) Either John is in the US, or John is in France and Chloe is in France with him.
\ex \(\not\implies \) Either John is in France and a contextual bodyof information entails that Chloe is with him, or else they're both in the US.
\end{xlist}
#+end_exe

#+begin_importantblock
The patters above aren't decisive evidence against the classical view, as Rothschild emphasizes. It's easy to set the context in a way that makes sense of these intuitions, in a classical setting. However, the regularity suggests that the classical account is missing a generalization.
#+end_importantblock

** Test semantics

The /locus classicus/ for epistemic modality in DS is Veltman's test semantics [cite:@Veltman1996].

Veltman's idea: a sentence \(\Diamond\phi \) is an instruction to hypothetically update a context \(c\) with \(\phi \), returning \(c\) unchanged if \(c\) can be consistently updated with \(\phi\), and the absurd state otherwise. 

#+name: might1
#+begin_exe
\ex \(c[\text{it might be raining}]\)
\begin{xlist}
\ex Compute \(c[\text{it's raining}]\); store the result as \(c'\).
\ex Is \(c'\) are non-absurd information state? If so, return \(c\).
\ex Otherwise, return \(c'\).
\end{xlist}
#+end_exe

An update semantics for a simple propositional fragment [cite:@Veltman1996].

#+begin_definition
*Test semantics for /might/.*

\[c[\Diamond \phi] := \begin{cases}
c & c[\phi] \neq \emptyset\\
\phi & \text{otherwise} 
\end{cases}\]
#+end_definition

In Veltman's update semantics, \(\emptyset \) is the /absurd state/, i.e., the information state from which everything follows.

If we define update-semantic negation, we can treat /must/ as the dual of /might/.

#+name: def:neg
#+begin_exe
\ex \(c[\neg \phi] := c - c[\phi]\)
#+end_exe

#+begin_definition
*Test semantics for /must/.*

\[c[\Box \phi] := c[\neg\Diamond\neg\phi]\]

\[c[\Box \phi] := \begin{cases}
c&c[\phi] = c\\
\emptyset&\text{otherwise} 
\end{cases}\]
#+end_definition

In Veltman's terms, /must \(\phi \)/ is true in a context \(c\) if \(\phi \) is /accepted/ in \(c \).

Note that test semantics for /must/ is *strong* [cite:@vonFintelGillies2010;@FintelGillies2021].

#+begin_definition
*Entailment in update semantics.*

\(\phi\text{ entails }\psi \iff \forall c[c[\phi] = c \rightarrow c[\psi] = c]\)
#+end_definition

If \(c[\Box\phi] = c\) then \(c[\phi] = c\), simply by the update rule for \(\Box \phi \).

#+begin_tipblock
Exercise: how does this idea make sense of the observation that epistemic /must/ is sensitive to local information state?
#+end_tipblock

** Modality and hypothetical discourse referents

We've seen evidence that modalized statements can introduced discourse referents.

#+name: maybe-conj
#+begin_exe
\ex Maybe there's no\(^v\) bathroom, and maybe it\(_v\)'s upstairs.
#+end_exe

A first stab at trying to make sense of this:

#+begin_importantblock
Asserting "possibly \(\phi \)" introduces the same anaphoric information as "\(\phi \) or not \(\phi \)".
#+end_importantblock
  
In a classical setting \(\phi \vee \neg \phi\) is of course informationally trivial, but in a dynamic setting (specifically, in the context of EDS), \(\phi \vee \neg \phi \), can introduce anaphoric information.

A consideration of the disjunctive case will help give a feel for the explanation.

#+name: triv1
#+begin_exe
\ex Either there's a\(^v\) bathroom, or there's no\(^v\) bathroom.
\ex \(\exists_v[B(v)] \vee \neg\exists_v[B(v)]\)
#+end_exe

Predicted (positive) meaning in EDS is as follows. Note:

- Since the disjuncts are mutually exclusive, we can ignore the case of both disjuncts being true.
- Since neither disjunct contains a free variable, we can ignore the case of either disjunct being undefined (ignoring the novelty condition for simplicity).
- There are therefore two ways of dynamically verifying the disjunction to consider:
  * The first disjunct is true, and the second is false (a bathroom dref).
  * The first disjunct is false and the second is true (no bathroom dref).
    
#+name: triv2
#+begin_exe
\ex \(\eval*[w,g][+]{.} = \begin{aligned}[t]
&\set{g^{[v \to x]}|\mathbf{bathroom}_w(x)}\\
&\cup \set{g | \mathbf{bathroom}_w = \emptyset }
\end{aligned}\)
#+end_exe

An assertion of ([[triv2]]) relative to a context \(c\) will introduce a bathroom discourse referent at worlds \(\in c\) where a bathroom exists, but otherwise leave the context unchanged, e.g.:

#+name: bath-ill
#+begin_exe
\ex \(\begin{aligned}[t]
&\set{(w_\emptyset,g),(w_{1},g),(w_{2},g),(w_{12},g)}\\
&\Rightarrow \set{(w_\emptyset,g),(w_{1},g^{[v \to b_1]}),(w_{2},g^{[v \to b_2]}),(w_{12},g^{[v \to b_1]}),(w_{12},g^{[v \to b_2]})}
\end{aligned}\)
#+end_exe

N.b. we already account for the impossibility of anaphora in the following discourse, due to the universal presupposition introduced by the pronoun.

#+name: pronoun
#+begin_exe
\ex Either there's a\(_v\) bathroom, or there isn't a bathroom.\\
??It\(_v\)'s upstairs.
#+end_exe

* Integrating epistemic modality and EDS

Since epistemic modals irreducibly make reference to /information states/ rather than evaluation points, in order to integrate them into our semantics compositionally, we need to systematically lift EDS into an /update semantics/.

EDS can be framed as an update semantics EUS - /Externally-dynamic Update Semantics/ - quite easily. Let's start with first-order EDS.

** EDS \(\to \) EUS

*** Lifting algorithm

As usual, we'll model information states using Heimian files, supplemented with a failure state \(\#_c\).

EDS is systematically lifted into EUS, a multivalent update semantics where we define \(c[.]_+\), \(c[.]_-\), and \(c[.]_u\).

#+name: eds:bridge
#+begin_exe
\ex 
\begin{xlist}
\ex \(c[\phi]_+ := \bigcup\limits_{(w,g) \in c}\set{(w,h)|(g,h) \in \eval*[w][+]{\phi }}\)
\ex \(c[\phi]_- := \bigcup\limits_{(w,g) \in c}\set{(w,h)|(g,h) \in \eval*[w][-]{\phi }}\)
\ex \(c[\phi]_u := \bigcup\limits_{(w,g) \in c}\set{(w,h)|(g,h) \in \eval*[w][u]{\phi }}\)
\end{xlist}
#+end_exe

#+begin_warningblock
Pay attention to an implicit change in notation. Previously, we used \(c[\phi]\) to indicate a pragmatic assertion rule for \(\phi \). Now, we're using \(c[.]_{+,-,u}\) to talk about the /semantic value/ of \(\phi \). We're now cleaving somewhat closer to the dynamic slogan: /the meaning of a sentence lies in how it changes an input information state/.
#+end_warningblock

*** Atomic sentences

Atomic sentences in EDS update semantics induce a tripartition of the input context. 

#+name: upd:atomic
#+begin_exe
\ex \(c[P(v_1,\ldots,v_n)]_+ := \set{(w,g) \in  c||P(v_1,\ldots,v_n)|^{w,g}\text{is \textbf{true}} }\)
\ex \(c[P(v_1,\ldots,v_n)]_- := \set{(w,g) \in  c||P(v_1,\ldots,v_n)|^{w,g}\text{is \textbf{false}} }\)
\ex \(c[P(v_1,\ldots,v_n)]_u := \set{(w,g) \in  c||P(v_1,\ldots,v_n)|^{w,g}\text{is \textbf{undefined}} }\)
#+end_exe

*** Negative sentences

#+name: upd:neg
#+begin_exe
\ex \(c[\neg\phi]_+ := c[\phi]_-\)
\ex \(c[\neg\phi]_- := c[\phi]_+\)
\ex \(c[\neg\phi]_u := c[\phi]_u\)
#+end_exe

*** Conjunctive sentences

The meanings of the connectives are identical, except relational composition is replaced by successive update.

#+name: upd:conj
#+begin_exe
\ex \(c[\phi \wedge \psi]_+ := c[\phi]_+[\psi]_+\)
\ex \(c[\phi \wedge \psi]_- := \begin{aligned}[t]
&c[\phi]_-[\psi]_+ \cup c[\phi]_-[\psi]_- \cup c[\phi]_-[\psi]_u\\
&c[\phi]_+[\psi]_- \cup c[\phi]_u[\psi]_-
\end{aligned}\)
\ex \(c[\phi \wedge \psi]_u := \begin{aligned}[t]
&c[\phi]_+[\psi]_u\\
&c[\phi]_u[\psi]_+ \cup c[\phi]_u[\psi]_u
\end{aligned}\)
#+end_exe

*** Random assignment

#+name: upd:rand
#+begin_exe
\ex \(c[\varepsilon_v]_+ := \set{(w,h)|\exists g[(w,g) \in c \wedge g[v]h]}\)
\ex \(c[\varepsilon_v]_- := \emptyset \)
\ex \(c[\varepsilon_v]_u := \emptyset \)
#+end_exe

*** Closure

#+name: upd:clo
#+begin_exe
\ex \(c[\dag\phi]_+ := c[\phi]_+\)
\ex \(c[\dag\phi]_- := \set{(w,g) \in c | c[\phi]_+ = \emptyset \wedge c[\phi]_- \neq \emptyset }\)
\ex \(c[\dag\phi]_u := c[\phi]_u\)
#+end_exe

*** Test semantics in EUS

Let's stick to Veltman's idea that a modalized statement, if true, adds no information to the CG.

#+name: upd:test
#+begin_exe
\ex /Might/ (first attempt):
\begin{xlist}
\ex \(c[\Diamond\phi]_+ := \set{(w,g) \in c| c[\phi]_+ \neq \emptyset }\)
\ex \(c[\Diamond\phi]_- := \set{(w,g) \in c | c[\phi]_+ = \emptyset \wedge c[\phi]_- \neq \emptyset }\)
\ex \(c[\Diamond\phi]_u := c[\phi]_u\)
\end{xlist}
#+end_exe

By definition, modalized sentences are /tests/ on information states (they can't introduce any anaphoric information).

*** Pragmatics

What kind of bridge principle do we want for a trivalent update semantics?

#+begin_definition
*Assertion*. An assertion of \(\phi \) in \(c\), \(c[\phi]\), is defined as follows:

\[c[\phi] := \begin{cases}
c[\phi]_+&c[\phi]_u = \emptyset\\
\#_c&\text{otherwise} 
\end{cases}\]
#+end_definition

#+begin_warningblock
A problem with our test semantics for /might/ is that it can't introduce /any/ anaphoric information into the context set. This will inevitably fail as an account of conjunctive bathroom sentences.
#+end_warningblock

*** An alternative semantics for /might/ 

Let's start by specifying the positive contribution of /might/.

#+name: upd:test
#+begin_exe
\ex /Might/ (first attempt):
\begin{xlist}
\ex \(c[\Diamond\phi]_+ := \begin{cases}
c[\phi]_+ \cup c[\phi]_-&c[\phi]_+ \neq \emptyset\\
\emptyset&\text{otherwise} 
\end{cases}\)
\end{xlist}
#+end_exe

We'll come back to the negative update associated with \(\Diamond \phi \).

*** Bathrooms and contextual entailment

This has the virtue of accounting for a variant of Rothshchild discourses involving epistemic modals.

#+name: critic
#+begin_exe
\ex Context: /It's common ground that a restaurant critic will be here on Monday, but it's not common ground what day it is./
\begin{xlist}
\ex A: It's possible that a restaurant critic is here.
\ex B: It's Monday, so they\(_v\)'re here right now.
\end{xlist}
#+end_exe

#+name: poss-critic
#+begin_exe
\ex 
\begin{xlist}
\ex It's possible that a restaurant critic is here.
\ex \(\Diamond (\exists_v[C(v)])\)
\end{xlist}
#+end_exe

#+name: poss
#+begin_exe
\ex \(c[\Diamond(\exists_v[C(v)])]_+ = \begin{cases}
c[\neg\exists_v[C(v)]]_+\cup c[\exists_v[C(v)]]_+& \exists w\in c[ I_w(C) \neq \emptyset]\\
\emptyset & \text{otherwise}
\end{cases}\) 
#+end_exe

In plain English, "it's possible that a\(^v\) critic is here" is an instruction to take a file \(c\), and:

- Check that there is at least one world where a critic is here (Veltman's consistency test).
- Update \(c\) with the information that there is a critic \(v\), giving back \(c'\).
- Update \(c\) with the information that there is no critic, giving back \(c''\).
- Return \(c \cup c'\).

If a subsequent update eliminates all non-critic worlds in \(c'\), then anaphora may subsequently be licensed (since familiarity will be satisfied).

*** Conjunctive possibilities

Recall our conjunctive bathroom sentence.

#+name: 
#+begin_exe
\ex There might be no\(^v\) bathroom and it\(_v\) might be upstairs.
#+end_exe

Let's compute the positive contribution of the first sentence.

#+name: poss
#+begin_exe
\ex \(c[\Diamond(\neg\exists_v[B(v)])]_+ = \begin{cases}
c[\neg\exists_v[B(v)]]_+\cup c[\exists_v[B(v)]]_+& \exists w\in c[ I_w(B) = \emptyset]\\
\emptyset & \text{otherwise}
\end{cases}\) 
#+end_exe

This update ensures that \(c\) is consistent with their being no bathroom, and pairs bathroom worlds with bathroom drefs, and leaves non-bathroom worlds unchanged.

Let's move on to the second sentence.

#+name: poss-bath2
#+begin_exe
\ex It\(_v\) might be upstairs.
\ex \(\Diamond(U(v))\)
#+end_exe

This update ensures that \(c\) is consistent with \(v\) being upstairs, and simply returns the union of the \(v-\)upstairs and \(v\)-not-upstairs worlds.

#+name: poss2
#+begin_exe
\ex \(c[\Diamond(U(v))]_+ = \begin{cases}
c[U(v)]_+ \cup c[U(v)]_-&c[U(v)]_+ \neq \emptyset\\
\emptyset &\text{otherwise} 
\end{cases} \)
#+end_exe

We can now think through, what happens when we chain these updates together. That's pretty easy for conjunction.

#+name: chain
#+begin_exe
\ex \(c[\Diamond(\neg\exists_v[B(v)]) \wedge \Diamond(U(v))]_+ = c[\Diamond(\neg\exists_v[B(v)])]_+[\Diamond(U(v))]_+\)
#+end_exe

#+begin_warningblock
Oh no! something has gone wrong here. Concretely, the update expressed by the second sentence requires that the familiarity presupposition is met /throughout/ the input context. If the test imposed by the first epistemic modal is successful, there are guaranteed to be worlds in which there are no bathrooms, and the second update will fail.
#+end_warningblock

Solution: existential projection for epistemic modals:

#+name: existential
#+begin_exe
\ex John might stop smoking.
\ex John might have smoked, and he might stop smoking.
#+end_exe

A modification of Veltman's test semantics: "might \(\phi \)" introduces a subset of \(c\) as a discourse referent \(c'\) that passes the consistency test, and asserts \(c'[\phi \vee \psi']\).

This is something we need independently to account for modal subordination.

To be continued next time...

#+print_bibliography:

* Footnotes
[fn:7] \(P \circ Q := \set{(x,y)|\exists z[(x,z) \in P \wedge (z,y) \in Q]}\) 
[fn:6] Thanks to Yasu Sudo for discussion of this point. 
[fn:5] Yanovich calls this view "contextual sollipsism" [cite:@Yanovich2014]. 
[fn:3] We use \(c_w\) to indicate the worldly content of a file, and \(c_w[\phi]\) to indicate the worldly content of \(c[\phi]\).
[fn:2] Note that a possible alternative would be to invoke some notion of Strawson entailment ([cite:@vonFintel1999]), adapted to file contexts. This would impose a too-weak-requirement on, e.g., bathroom disjunctions, since the \(U(v)\) merely presupposes that \(v\) is defined.
[fn:1] Much the same point can be made for non-anaphoric presuppositions. 

* File local variables                                             :noexport:
 
# Local Variables:
# mode: org
# org-latex-default-packages-alist: nil
# org-latex-with-hyperref: nil
# End:

